<!-- Welcome to the Frontend -->
<!-- https://github.com/jubewe/lightcontroller -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lightcontroller</title>
  </head>

  <body>
    <h3>Lightcontroller</h3>
    <div id="lightcontrolsgroup"></div>
    <div id="lightcontrols"></div>
  </body>

  <footer>
    <h>This Controller was made by</h>
    <a href="https://github.com/jubewe">Julian (Frontend)</a>
    <a href="https://github.com/jojo-06">Johannes (PCB + Backend)</a>
    <a href="https://github.com/jubewe/lightcontroller"
      >Documentation (GitHub)</a
    >
  </footer>
</html>
<script>
  const url = new URL(document.baseURI);

  const splitter = "---";
  const presetAddressSplitter = "-";
  const presetChannelSplitter = ",";
  const presetEntrySplitter = ";";

  let elementsLoaded;

  const lightConfig =
    "Spot Links Außen Hinten;1;6;Bühne,Links,Bühne Links,Bühne Hinten,Bühne Außen,Bühne Links Außen,Bühne Links Hinten---Spot Links Innen Vorne;31;6;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Innen,Bühne Links Innen,Bühne Links Vorne---Spot Rechts Innen Vorne;37;6;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Innen,Bühne Rechts Innen,Bühne Rechts Vorne---Spot Rechts Außen Hinten;19;6;Bühne,Rechts,Bühne Rechts,Bühne Hinten,Bühne Außen,Bühne Rechts Außen,Bühne Rechts Hinten---Spot Links Oben;49;6;Spots,Spots Links,Spots Oben,Links---Spot Links Unten;55;6;Spots,Spots Links,Spots Unten,Links---Spot Rechts Oben;61;6;Spots,Spots Rechts,Spots Oben,Rechts---Spot Rechts Unten;67;6;Spots,Spots Rechts,Spots Unten,Rechts";

  // old(07/19/2023) "Spot Links Außen Hinten;1;6;Bühne,Links,Bühne Links,Bühne Hinten,Bühne Außen,Bühne Links Außen,Bühne Links Hinten---------Spot Rechts Außen Hinten;19;6;Bühne,Rechts,Bühne Rechts,Bühne Hinten,Bühne Außen,Bühne Rechts Außen,Bühne Rechts Hinten------Spot Links Innen Vorne;31;6;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Innen,Bühne Links Innen,Bühne Links Vorne---Spot Rechts Innen Vorne;37;6;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Innen,Bühne Rechts Innen,Bühne Rechts Vorne------Spot Links Oben;49;6;Spots,Spots Links,Spots Oben,Links---Spot Links Unten;55;6;Spots,Spots Links,Spots Unten,Links---Spot Rechts Oben;61;6;Spots,Spots Rechts,Spots Oben,Rechts---Spot Rechts Unten;67;6;Spots,Spots Rechts,Spots Unten,Rechts";
  // old (07/18/2023) "Spot Links Außen Hinten;1;6;Bühne,Links,Bühne Links,Bühne Hinten,Bühne Außen,Bühne Links Außen,Bühne Links Hinten---Bühne Links Innen Hinten;7;1;Bühne,Links,Bühne Links,Bühne Hinten,Bühne Innen,Bühne Links Innen,Bühne Links Hinten---Bühne Rechts Innen Hinten;13;1;Bühne,Rechts,Bühne Rechts,Bühne Hinten,Bühne Innen,Bühne Rechts Innen,Bühne Rechts Hinten---Spot Rechts Außen Hinten;19;6;Bühne,Rechts,Bühne Rechts,Bühne Hinten,Bühne Außen,Bühne Rechts Außen,Bühne Rechts Hinten---Bühne Links Außen Vorne;25;1;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Außen,Bühne Links Außen,Bühne Links Vorne---Bühne Links Innen Vorne;31;1;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Innen,Bühne Links Innen,Bühne Links Vorne---Bühne Rechts Innen Vorne;37;1;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Innen,Bühne Rechts Innen,Bühne Rechts Vorne---Bühne Rechts Außen Vorne;43;1;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Außen,Bühne Rechts Außen,Bühne Rechts Vorne---Spot Links Oben;49;6;Spots,Spots Links,Spots Oben,Links---Spot Links Unten;55;6;Spots,Spots Links,Spots Unten,Links---Spot Rechts Oben;61;6;Spots,Spots Rechts,Spots Oben,Rechts---Spot Rechts Unten;67;6;Spots,Spots Rechts,Spots Unten,Rechts---Spot Bühne Vorne Links;73;6;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Links Vorne---------Spot Bühne Vorne Rechts;79;6;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Rechts Vorne";
  // old (07/06/2023) "Bühne Links Außen Hinten;1;1;Bühne,Links,Bühne Links,Bühne Hinten,Bühne Außen,Bühne Links Außen,Bühne Links Hinten---Bühne Links Innen Hinten;7;1;Bühne,Links,Bühne Links,Bühne Hinten,Bühne Innen,Bühne Links Innen,Bühne Links Hinten---Bühne Rechts Innen Hinten;13;1;Bühne,Rechts,Bühne Rechts,Bühne Hinten,Bühne Innen,Bühne Rechts Innen,Bühne Rechts Hinten---Bühne Rechts Außen Hinten;19;1;Bühne,Rechts,Bühne Rechts,Bühne Hinten,Bühne Außen,Bühne Rechts Außen,Bühne Rechts Hinten---Bühne Links Außen Vorne;25;1;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Außen,Bühne Links Außen,Bühne Links Vorne---Bühne Links Innen Vorne;31;1;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Innen,Bühne Links Innen,Bühne Links Vorne---Bühne Rechts Innen Vorne;37;1;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Innen,Bühne Rechts Innen,Bühne Rechts Vorne---Bühne Rechts Außen Vorne;43;1;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Außen,Bühne Rechts Außen,Bühne Rechts Vorne---Spot Links Oben;49;6;Spots,Spots Links,Spots Oben,Links---Spot Links Unten;55;6;Spots,Spots Links,Spots Unten,Links---Spot Rechts Oben;61;6;Spots,Spots Rechts,Spots Oben,Rechts---Spot Rechts Unten;67;6;Spots,Spots Rechts,Spots Unten,Rechts";
  console.debug("Loaded config", lightConfig);
  const RGBchannels = [
    ["Red", "r", "#ff0000", 0],
    ["Green", "g", "#00ff00", 0],
    ["Blue", "b", "#0000ff", 0],
    ["White", "w", "#ffffff", 255],
    ["Amber", "a", "#ffbf00", 0],
    ["UV", "u", "#5f4b8b", 0],
  ];

  const rangeInputMin = 0;
  const rangeInputMax = 255;
  const rangeInputDefault = 0;

  const fadeRangeMin = 0;
  const fadeRangeMax = 30; /* seconds, gets converted into milliseconds */
  const fadeRangeDefault = 0;
  const fadeDefaultTime = 1;
  const fadeLiveDefaultTime = 0;

  const channelsPerRGBLight = 6;
  let groups = {};
  let liveUpdate = false;
  let groupToggle = true;
  let channelsToggle = true;
  let lightStates = {
    channels: {},
    groups: {},
    master: "",
  };
  // group: <dmxaddr.join("-")>,r,g,b,w,a,u,dimm,fade;...

  let fullOn = 0;
  let fullOff = 0;
  let quickStates = {
    fullOn: {
      _all: 0,
    },
    fullOff: {
      _all: 0,
    },
  };
  // 0 = disabled, 1 = active, 2 = overridden by other mode

  let lights = lightConfig;
  lights.split(splitter).forEach((line) => {
    let splits = line.split(";");
    let groups_ = splits[3];
    if ((groups_?.length ?? 0) === 0) return;
    groups_.split(",").forEach((group) => {
      if (!groups[encodeURI(group)]) groups[encodeURI(group)] = [];
      groups[encodeURI(group)].push(line);
    });
  });

  lights = lights
    .split(splitter)
    .filter((a) => a.length > 0)
    .join(splitter);

  console.debug("Groups", groups);

  class functions {
    static request = (u, options) => {
      return new Promise((resolve, reject) => {
        if (!/^http(s)*:\/{2}/i.test(u)) u = url.origin + u;
        options = options ?? {};

        fetch(u, options)
          .then((v) => {
            resolve(v.body);
          })
          .catch(reject);
      });
    };

    static submitConfig = (config) => {
      this.request("/config", {
        headers: {
          plain: typeof config !== "string" ? JSON.stringify(config) : config,
        },
        method: "POST",
      })
        .then(() => {
          console.debug("POST Config Success");
        })
        .catch((e) => {
          console.error("POST Config error", e);
        });
    };

    static getWhite = (hex) => {
      if (hex.replace(/^#/, "").toLowerCase() === "ffffff") return 255;
      return 0;
    };

    static hexToRGBParsed = (hex) => {
      /* let w = functions.getWhite(hex);
                  let rgb = functions.hexToRGB(hex); */
      return functions.hexToRGB(hex);

      // let r = {
      //     /* ...(w === 255 ? { r: 0, g: 0, b: 0 } : rgb),
      //     w: w */
      // };

      // return r;
    };

    static hexToRGB = (hex) => {
      let r = {};
      let hexParts = hex.replace(/^#/, "").match(/\w{2}/g);
      hexParts.forEach((a, i) => (r[["r", "g", "b"][i]] = parseInt(a, 16)));
      return r;
    };

    static RGBToHex = (r, g, b, w) => {
      let hex = "#";
      /* if (w && (w == 255)) return "#ffffff"; */
      hex += functions.pad2(Math.abs(r).toString(16));
      hex += functions.pad2(Math.abs(g).toString(16));
      hex += functions.pad2(Math.abs(b).toString(16));
      return hex;
    };

    static pad2 = (n) => {
      if (!/^\d$/.test(n)) return `${n.length < 2 ? "0" : ""}${n}`;
      return `${parseInt(n) < 10 ? "0" : ""}${n}`;
    };

    static getValuesFromChannels = (containerID) => {
      let r = {};
      RGBchannels.forEach((channel) => {
        r[channel[1]] = document.getElementById(
          `${containerID}-channels-${channel[1]}`
        ).value;
      });
      return r;
    };

    static appendValuesFromChannels = (containerID) => {
      let vals = functions.getValuesFromChannels(containerID);
      let [r, g, b] = [vals.r, vals.g, vals.b];
      let hex = functions.RGBToHex(r, g, b);
      document.getElementById(`${containerID}-color`).value = hex;
      return hex;
    };

    static appendHexToChannels = (containerID, hex) => {
      let hex_ = hex ?? document.getElementById(`${containerID}-color`).value;
      let rgb = functions.hexToRGBParsed(hex_);

      let r = {};
      Object.keys(rgb).forEach((channel) => {
        document.getElementById(`${containerID}-channels-${channel}`).value =
          rgb[channel];
        r[channel] = rgb[channel];
      });
      return r;
    };

    static appendToChannels = (containerID, pickedChannels) => {
      Object.keys(pickedChannels).forEach((channel) => {
        document.getElementById(`${containerID}-channels-${channel}`).value =
          pickedChannels[channel];
      });
    };

    static parseWSUpdateMessage = (addr, dimm, r, g, b, w, a, u, fade) => {
      let args = [addr, r, g, b, w, a, u, (fade ?? 0) * 1000];
      let argsParsed = [
        addr,
        ...args
          .slice(1, 7)
          .map((arg) => Math.floor(parseInt(arg) * (1 - (dimm ?? 0) / 100))),
        fade * 1000,
      ];
      return [].concat(argsParsed, Array(8).slice(0, 8 - argsParsed.length));
    };

    static updateLight = (addr, dimm, r, g, b, w, a, u, fade) => {
      if (addr.length === 0) return;
      let msg = this.parseWSUpdateMessage(addr, dimm, r, g, b, w, a, u, fade);
      console.debug("WS Update RGB", msg.join(";"));
      ws?.send(msg.join(";"));
    };

    static parseWSUpdateMessagenoRGB(addr, dimm, fade) {
      return [
        addr,
        Math.floor(255 * (1 - dimm / 100)),
        ...[...Array(5)].map((a) => 0),
        fade * 1000,
      ];
    }

    static updateLightnoRGB = (addr, dimm, fade) => {
      if (addr.length === 0) return;
      console.debug(
        "WS Update Non-RGB",
        [
          addr,
          Math.floor(255 * (1 - dimm / 100)),
          ...[...Array(5)].map((a) => 0),
          fade * 1000,
        ].join(";")
      );
      ws?.send(this.parseWSUpdateMessagenoRGB(addr, dimm, fade).join(";"));
    };

    static updateLightVal = (addr, vals, fade) => {
      if (addr.length === 0) return;
      let vals_ = vals;
      if (!Array.isArray(vals_)) vals_ = [...Array(6)].map((a) => vals);
      console.debug("WS Update Val", [addr, ...vals_, fade * 1000].join(";"));

      let rgbChans = ws?.send([addr, ...vals_, fade * 1000].join(";"));
    };

    static quickButtonActive = (elem) => {
      elem.classList.add("quickActionButton-active");
      // elem.setAttribute("state", "1");
    };

    static quickButtonInactive = (elem) => {
      elem.classList.remove("quickActionButton-active");
      // elem.setAttribute("state", "0");
    };

    static getQuickState = (ag, a) => {
      return quickStates[ag]?.[a] ?? 0;
    };

    static appendHeld = (groupName) => {
      let held = quickStates[groupName()];
      if (!held?.heldActions) return;
      let updatesRGB = [];
      let updatesnoRGB = [];

      /*
      let appendActions = {
        channels: [[], [], [], [], [], []],
        addresses: {},
      };

      held.heldActions.forEach((heldAction) => {
        if (heldAction[0].length === 0) return;

        let addresses = heldAction[0];
        addresses.forEach((address) => {
          appendActions.addresses[address] = heldAction.slice(1, 7);
        });
      });

      // Object.keys(appendActions.addresses).forEach((address) => {
      //   let channels = appendActions.addresses[address];

      //   channels.forEach((channel, i) => {
      //     let channelName = Object.keys(appendActions.channels)[i];

      //     if (!appendActions.channels[i].filter((a) => a[0] === channel)[0])
      //       appendActions.channels[i].push([channel, []]);

      //     appendActions.channels[i]
      //       .filter((a) => a[0] === channel)[0][1]
      //       .push(address);
      //   });
      // });

      // appendActions.channels.forEach((channel) => {
      //   channel.forEach((update) => {
      //     updates.push([update[1].join(","),]);
      //   });
      // });
      */

      held.heldActions.reverse().forEach((a) => {
        let rgbUpdates = a[0];
        let norgbUpdates = a[1];

        function append(b, c) {
          if (
            b[0].length === 0 ||
            c.filter((d) => d[0].join(";") === b[0].join(";"))[0]
          )
            return;

          c.push(b);
        }

        append(rgbUpdates, updatesRGB);
        append(norgbUpdates, updatesnoRGB);
      });

      updatesRGB.forEach((a) => {
        functions.updateLight(...a);
      });

      updatesnoRGB.forEach((a) => {
        functions.updateLightnoRGB(...a);
      });

      held.heldActions = [];
    };

    static disableElem = (elem) => {
      elem.disabled = true;
    };

    static enableElem = (elem) => {
      elem.removeAttribute("disabled");
    };

    static getAddrChanNum = (addr) => {
      let a = lights
        .split(splitter)
        .filter((a) => a.split(";")[1] === addr.toString());

      return a[0]?.split(";")[2];
    };

    static getLightByAddr = (addr) => {
      return lights
        .split(splitter)
        .filter((a) => a.split(";")[1] === addr.toString())[0];
    };

    static updateGroups = (
      pickedDimm,
      pickedFade,
      pickedColorHex,
      pickedChannels
    ) => {
      if (!document.getElementById(`controlsGroup`)) return;
      document.getElementById(`controlsGroup-color`).value = pickedColorHex;
      document.getElementById(`controlsGroup-dimm`).value = pickedDimm ?? 0;
      document.getElementById(`controlsGroup-fade`).value = pickedFade ?? 0;
      functions.appendToChannels(`controlsGroup`, pickedChannels);
    };

    static isRGB = (addr) => {
      return this.getAddrChanNum(addr) === "6";
    };

    static appendFromStrings = (s) => {
      // ws: <dmxstart>,r,g,b,w,a,u;<dmxstart>...
      let groupName;
      let dmxStrings = s
        .split(presetEntrySplitter)
        .map((a) => a.split(presetChannelSplitter));
      let normalDMXStrings = dmxStrings;

      let controlsChannelsRGB = ["r", "g", "b", "w", "a", "u"];
      let controlsClassNames = ["dimm", "fade"];

      let controlsClassNamesRGB = [
        ...controlsChannelsRGB.map((a) => `channels-${a}`),
        ...controlsClassNames,
      ];

      normalDMXStrings.forEach((normalDMXString) => append(normalDMXString));

      function append(dmxString) {
        let [dmxStart, r, g, b, w, a, u, dimm, fade] = dmxString;
        let dmxStart_ = dmxStart.split(presetAddressSplitter);
        let groupName;

        if (typeof dmxStart === "string" && !/^\d$/.test(dmxStart)) {
          switch (dmxStart.split(":")[0]) {
            case "master": {
              dmxStart_ = lights.split(splitter).map((a) => a.split(";")[1]);

              groupName = "controlsGroupAll";

              break;
            }

            default: {
              dmxStart_ = dmxStart
                .split(":")
                .at(-1)
                .split(presetAddressSplitter);

              groupName = "controlsGroup";

              break;
            }
          }
        }

        let isRGB =
          (groupName ?? undefined) !== undefined || functions.isRGB(dmxStart);

        let groupName_ = groupName ?? `controls${dmxStart}`;

        let elementIDs = controlsClassNamesRGB.map(
          (className) => `${groupName_}-${className}`
        );

        let elements = elementIDs.map((className) =>
          functions.getElementByID(className)
        );

        elements.forEach((element, i2) => {
          if (!element) return;
          element.value = dmxString[i2 + 1]; // +1: skip dmxStart
        });

        if (isRGB) {
          functions.appendValuesFromChannels(groupName_);

          let lights_ = dmxStart_;

          let hex = functions.RGBToHex(r, g, b);
          let channelValues = functions.getValuesFromChannels(groupName_);

          if (lights_.length > 0) {
            functions.append(
              lights_.map((addr) => functions.getLightByAddr(addr)),
              dimm ?? 0,
              fade ?? 0,
              hex,
              channelValues
            );

            functions.append(
              "master",
              dimm ?? 0,
              fade ?? 0,
              hex,
              channelValues,
              "controlsGroup"
            );

            functions.updateGroups(dimm, fade, hex, channelValues);
          }
        }
      }
    };

    static getElementByID = (id) => {
      return document.getElementById(id) ?? undefined;
    };

    static convertToArray = (a) => {
      if (!a) return [];
      return !Array.isArray(a) ? [a] : a;
    };

    static append = (
      lights_,
      pickedDimm,
      pickedFade,
      pickedColorHex,
      pickedChannels,
      groupName
    ) => {
      functions.convertToArray(lights_).map((light) => {
        let dmxStart = light?.split(";")?.[1] ?? light;
        let groupName_ = groupName ?? `controls${dmxStart}`;

        if (!document.getElementById(groupName_))
          return console.error("could not find controls", dmxStart, light);

        let isRGB = parseInt(light.split(";")[2]) > 1;

        document.getElementById(`${groupName_}-dimm`).value = pickedDimm ?? 0;
        document.getElementById(`${groupName_}-fade`).value = pickedFade ?? 0;
        if (!isRGB) return;
        document.getElementById(`${groupName_}-color`).value = pickedColorHex;
        functions.appendToChannels(groupName_, pickedChannels);
      });
    };

    static addKeysToObjectSync = (object, keys, value) => {
      let keys_ = functions.convertToArray(keys);

      let parentObj = object;
      for (let i = 0; i < keys_.length - 1; i++) {
        let key = keys_[i];
        if (!(key in parentObj)) parentObj[key] = {};

        parentObj = parentObj[key];
      }

      parentObj[keys_[keys_.length - 1]] = value;
      return object;
    };

    static getKeyFromObjectSync = (object, keys) => {
      let keys_ = functions.convertToArray(keys);
      let value = object;
      for (let i = 0; i < keys_.length; i++) {
        if (value?.hasOwnProperty(keys_[i])) {
          value = value[keys_[i]];
        } else {
          return undefined;
        }
      }

      return value;
    };

    static deleteKeyFromObjectSync = (object, keys) => {
      let keys_ = functions.convertToArray(keys);
      let parentObj = object;
      for (let i = 0; i < keys_.length - 1; i++) {
        if (!(keys_[i] in parentObj)) {
          return undefined;
        } else {
          parentObj = parentObj[keys_[i]];
        }
      }
      let delkey = keys_[keys_.length - 1];
      delete parentObj[delkey];

      return object;
    };

    static localStorage = class {
      static #key = "l";

      static init = () => {
        let newStorage = { presets: {} };
        this.setStorage(newStorage);
      };

      static initIfNonexistent = () => {
        if (!(this.getStorage() ?? undefined)) this.init();
      };

      static getStorage = () => {
        let item = localStorage.getItem(this.#key);
        if (!(item ?? undefined)) return null;
        return JSON.parse(localStorage.getItem(this.#key));
      };

      static setStorage = (newStorage) => {
        localStorage.setItem(this.#key, JSON.stringify(newStorage));
      };

      static getKey = (keypath) => {
        let storage = this.getStorage();
        return functions.getKeyFromObjectSync(storage, keypath);
      };

      static setKey = (keypath, value) => {
        this.initIfNonexistent();
        let storage = this.getStorage();
        let newstorage = functions.addKeysToObjectSync(storage, keypath, value);
        this.setStorage(newstorage);
      };

      static deleteKey = (keypath) => {
        let storage = this.getStorage();
        let newstorage = functions.deleteKeyFromObjectSync(storage, keypath);
        this.setStorage(newstorage);
      };

      static emptyCache = () => {
        functions.localStorage.setKey("cache", {});
      };
    };

    static getPresets = () => {
      return this.localStorage.getKey(["presets"]) ?? {};
    };

    static setPreset = (presetName, presetValue) => {
      return this.localStorage.setKey(
        ["presets", encodeURI(presetName)],
        presetValue
      );
    };

    static deletePreset = (presetName) => {
      return this.localStorage.deleteKey(["presets", encodeURI(presetName)]);
    };

    static getPreset = (presetName) => {
      return this.localStorage.getKey(["presets", encodeURI(presetName)]);
    };
  }

  class scripts {
    static loadLights = () => {
      lightConfig.split(splitter).forEach((line, i) => {
        let isEmpty = line.length === 0;

        let [
          lightName,
          lightDmxAddress,
          lightChannels,
          lightGroupName,
        ] = line.split(";");
        let isRGB = parseInt(lightChannels) > 1;

        let controlsContainer = document.createElement("div");
        if (!isEmpty) controlsContainer.id = `controls${lightDmxAddress}`;
        controlsContainer.classList.add("controlsContainer");

        if (isEmpty) {
          controlsContainer.classList.add("empty");
          return document
            .querySelector("#lightcontrols")
            .appendChild(controlsContainer);
        }

        let controlsContainerTop = document.createElement("div");
        controlsContainerTop.classList.add("controlsContainerTop");

        let controlsContainerBottom = document.createElement("div");
        controlsContainerBottom.classList.add("controlsContainerBottom");

        let controlsTitle = document.createElement("h");
        controlsTitle.classList.add("controlsTitle");
        if (!isEmpty) controlsTitle.innerText = lightName;

        let controlsGroupTitle = document.createElement("h");
        controlsGroupTitle.classList.add("controlsGroupTitle");
        if (!isEmpty)
          controlsGroupTitle.innerText = lightGroupName.split(",").join(", ");

        let controlsColorInput = elements.controlsColorInput(
          controlsContainer.id
        );
        let controlsChannelInputs = elements.controlsChannelInputs(
          controlsContainer.id
        );
        let controlsDimmerInput = elements.controlsDimmerInput(
          controlsContainer.id
        );
        let controlsFadeInput = elements.controlsFadeInput(
          controlsContainer.id
        );

        controlsColorInput.onchange = () => {
          append();
          functions.appendHexToChannels(controlsContainer.id);
        };
        controlsChannelInputs.onchange = () => {
          append();
          functions.appendValuesFromChannels(controlsContainer.id);
        };
        controlsDimmerInput.onchange = () => {
          append();
        };
        controlsFadeInput.onchange = () => {
          append();
        };

        let controlsSubmit = document.createElement("button");
        controlsSubmit.innerText = "Update";
        controlsSubmit.classList.add("controlsSubmit");
        controlsSubmit.onclick = () => {
          append(true);
        };

        function append(update) {
          let pickedDimm = controlsDimmerInput.querySelector(
            ".controlsDimmerInput"
          ).value;
          let pickedFade = controlsFadeInput.querySelector(".controlsFadeInput")
            .value;

          let isOverridden =
            functions.getQuickState("_all", "fullOn") === 1 ||
            functions.getQuickState("_all", "fullOff") === 1;

          let isHeld = functions.getQuickState("_all", "isHeld") === 1;

          if (!isRGB) {
            lightStates.channels[lightDmxAddress] = [
              lightDmxAddress,
              ...Array(6).map((a) => ""),
              pickedDimm,
              pickedFade,
            ].join(presetChannelSplitter);

            if (isHeld) {
              quickStates._all.heldActions.push([
                [],
                [[lightDmxAddress], pickedDimm, pickedFade],
              ]);

              return;
            }

            if ((update || liveUpdate) && !isOverridden)
              functions.updateLightnoRGB(
                lightDmxAddress,
                pickedDimm,
                pickedFade
              );
            return;
          }

          let pickedColorHex = controlsColorInput.querySelector(
            ".controlsColorInput"
          ).value;
          let pickedColor = functions.hexToRGBParsed(pickedColorHex);
          let pickedChannels = functions.getValuesFromChannels(
            controlsContainer.id
          );

          let { r, b, g, w, a, u } = pickedChannels;
          lightStates.channels[lightDmxAddress] = [
            lightDmxAddress,
            ...Object.values({ r, b, g, w, a, u }),
            pickedDimm,
            pickedFade,
          ].join(presetChannelSplitter);

          if (isHeld) {
            quickStates._all.heldActions.push([
              [
                [lightDmxAddress],
                pickedDimm,
                ...Object.values(pickedChannels),
                pickedFade,
              ],
              [],
            ]);

            return;
          }

          if ((update || liveUpdate) && !isOverridden)
            functions.updateLight(
              lightDmxAddress,
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade
            );
        }

        [controlsTitle, controlsGroupTitle].map((a) =>
          controlsContainerTop.appendChild(a)
        );
        [
          ...(isRGB ? [controlsColorInput, controlsChannelInputs] : []),
          controlsDimmerInput,
          controlsFadeInput,
          controlsSubmit,
        ].forEach((a) => controlsContainerBottom.appendChild(a));
        [controlsContainerTop, controlsContainerBottom].map((a) =>
          controlsContainer.appendChild(a)
        );

        document.querySelector("#lightcontrols").appendChild(controlsContainer);
      });
    };

    static loadLightGroups = () => {
      let groupControlsContainer = document.createElement("div");
      groupControlsContainer.classList.add("groupControlsContainer");
      groupControlsContainer.id = "controlsGroup";

      let groupControlsTitle = document.createElement("h");
      groupControlsTitle.innerText = "Group Controls";
      groupControlsTitle.classList.add("controlsTitle");

      let groupSelector = document.createElement("select");
      groupSelector.classList.add("controlsSelector");
      Object.keys(groups).forEach((group) => {
        let groupOption = document.createElement("option");
        groupOption.innerText = decodeURI(group);
        groupOption.value = group;
        groupSelector.appendChild(groupOption);
      });

      let groupControlsColorInput = elements.controlsColorInput(
        groupControlsContainer.id
      );
      let groupControlsChannelInputs = elements.controlsChannelInputs(
        groupControlsContainer.id
      );
      let groupName = () => {
        return `_group_${groupSelector.value}`;
      };
      let groupControlsQuickActions = elements.controlsQuickActions(
        groupControlsContainer.id,
        groupName,
        append
      );
      let groupControlsDimmerInput = elements.controlsDimmerInput(
        groupControlsContainer.id
      );
      let groupControlsFadeInput = elements.controlsFadeInput(
        groupControlsContainer.id
      );

      let groupControlsSubmit = document.createElement("button");
      groupControlsSubmit.innerText = "Update";
      groupControlsSubmit.classList.add("controlsSubmit");

      groupControlsSubmit.onclick = () => {
        append(true);
      };
      groupControlsColorInput.onchange = () => {
        append(false, true, false);
      };
      groupControlsChannelInputs.onchange = () => {
        append(false, false, true);
      };
      groupControlsDimmerInput.onchange = () => {
        append();
      };
      groupControlsFadeInput.onchange = () => {
        append();
      };

      function append(update, fromPicker, fromChannels, quickOverrideVal) {
        let pickedColorHex = groupControlsColorInput.querySelector(
          ".controlsColorInput"
        ).value;
        let pickedDimm = groupControlsDimmerInput.querySelector(
          ".controlsDimmerInput"
        ).value;
        let pickedFade = groupControlsFadeInput.querySelector(
          ".controlsFadeInput"
        ).value;

        let pickedGroup = groupSelector.value;

        if (fromPicker)
          functions.appendHexToChannels(
            groupControlsContainer.id,
            pickedColorHex
          );

        if (fromChannels)
          pickedColorHex = functions.appendValuesFromChannels(
            groupControlsContainer.id
          );

        let pickedChannels = functions.getValuesFromChannels(
          groupControlsContainer.id
        );

        let isOverridden =
          functions.getQuickState(groupName(), "fullOn") === 1 ||
          functions.getQuickState(groupName(), "fullOff") === 1;

        let isHeld = functions.getQuickState(groupName(), "isHeld") === 1;

        let rgbChans = groups[pickedGroup]
          .filter((a) => parseInt(a.split(";")[2]) > 1)
          .map((a) => a.split(";")[1]);

        let noRGBChans = groups[pickedGroup]
          .filter((a) => parseInt(a.split(";")[2]) === 1)
          .map((a) => a.split(";")[1]);

        let { r, g, b, w, a, u } = pickedChannels;
        lightStates.groups[groupName()] = [
          `group:${groupName()}:${[...rgbChans, ...noRGBChans].join(
            presetAddressSplitter
          )}`,
          ...Object.values({ r, g, b, w, a, u }),
          pickedDimm,
          pickedFade,
        ].join(presetChannelSplitter);

        if (isHeld) {
          return quickStates[groupName()].heldActions.push([
            [
              rgbChans,
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade,
            ],

            [noRGBChans, pickedDimm, pickedFade],
          ]);
        }

        if (quickOverrideVal) {
          functions.updateLightVal(rgbChans, quickOverrideVal[0], 0);
          functions.updateLightVal(noRGBChans, quickOverrideVal[1], 0);
        } else if ((update || liveUpdate) && !isOverridden) {
          if (rgbChans.length > 0)
            functions.updateLight(
              rgbChans.join(","),
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade
            );

          if (noRGBChans.length > 0)
            functions.updateLightnoRGB(
              noRGBChans.join(","),
              pickedDimm,
              pickedFade
            );
        }

        functions.append(
          groups[pickedGroup],
          pickedDimm,
          pickedFade,
          pickedColorHex,
          pickedChannels
        );
      }

      [
        groupControlsTitle,
        groupSelector,
        groupControlsColorInput,
        groupControlsChannelInputs,
        groupControlsQuickActions,
        groupControlsDimmerInput,
        groupControlsFadeInput,
        groupControlsSubmit,
      ].forEach((a) => groupControlsContainer.appendChild(a));

      document
        .querySelector("#lightcontrolsgroup")
        .appendChild(groupControlsContainer);
    };

    static loadLightAll = () => {
      let allControlsContainer = document.createElement("div");
      allControlsContainer.classList.add("groupControlsContainer");
      allControlsContainer.id = "controlsGroupAll";

      let allControlsTitle = document.createElement("h");
      allControlsTitle.innerText = "Master Controls";
      allControlsTitle.classList.add("controlsTitle");

      let allControlsColorInput = elements.controlsColorInput(
        allControlsContainer.id
      );
      let allControlsChannelInputs = elements.controlsChannelInputs(
        allControlsContainer.id
      );
      let groupName = () => {
        return "_all";
      };
      let allControlsQuickActions = elements.controlsQuickActions(
        allControlsContainer.id,
        groupName,
        append
      );
      let allControlsDimmerInput = elements.controlsDimmerInput(
        allControlsContainer.id
      );
      let allControlsFadeInput = elements.controlsFadeInput(
        allControlsContainer.id
      );

      let allControlsSubmit = document.createElement("button");
      allControlsSubmit.innerText = "Update";
      allControlsSubmit.classList.add("controlsSubmit");

      allControlsSubmit.onclick = () => {
        append(true);
      };
      allControlsColorInput.onchange = () => {
        append(false, true, false);
      };
      allControlsChannelInputs.onchange = () => {
        append(false, false, true);
      };
      allControlsDimmerInput.onchange = () => {
        append();
      };
      allControlsFadeInput.onchange = () => {
        append();
      };

      function append(update, fromPicker, fromChannels, quickOverrideVal) {
        // quickOverrideVal = [[<rgb>],[<norgb>]]
        let pickedColorHex = allControlsColorInput.querySelector(
          ".controlsColorInput"
        ).value;
        let pickedDimm = allControlsDimmerInput.querySelector(
          ".controlsDimmerInput"
        ).value;
        let pickedFade = allControlsFadeInput.querySelector(
          ".controlsFadeInput"
        ).value;

        if (fromPicker)
          functions.appendHexToChannels(
            allControlsContainer.id,
            pickedColorHex
          );
        if (fromChannels)
          pickedColorHex = functions.appendValuesFromChannels(
            allControlsContainer.id
          );
        let pickedChannels = functions.getValuesFromChannels(
          allControlsContainer.id
        );

        let isOverridden =
          functions.getQuickState(groupName(), "fullOn") === 1 ||
          functions.getQuickState(groupName(), "fullOff") === 1;

        let isHeld = functions.getQuickState(groupName(), "isHeld") === 1;

        let rgbChans = lights
          .split(splitter)
          .filter((a) => parseInt(a.split(";")[2]) > 1)
          .map((a) => a.split(";")[1]);

        let noRGBChans = lights
          .split(splitter)
          .filter((a) => parseInt(a.split(";")[2]) === 1)
          .map((a) => a.split(";")[1]);

        let { r, g, b, w, a, u } = pickedChannels;

        lightStates.master = [
          `master:${[...rgbChans, ...noRGBChans].join(presetAddressSplitter)}`,
          ...Object.values({ r, g, b, w, a, u }),
          pickedDimm,
          pickedFade,
        ].join(presetChannelSplitter);

        if (isHeld)
          return quickStates[groupName()].heldActions.push([
            [
              rgbChans,
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade,
            ],
            [noRGBChans, pickedDimm, pickedFade],
          ]);

        if (quickOverrideVal) {
          functions.updateLightVal(rgbChans, quickOverrideVal[0], 0);
          functions.updateLightVal(noRGBChans, quickOverrideVal[1], 0);
        } else if ((update || liveUpdate) && !isOverridden) {
          if (rgbChans.length > 0)
            functions.updateLight(
              rgbChans.join(","),
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade
            );

          if (noRGBChans.length > 0)
            functions.updateLightnoRGB(
              noRGBChans.join(","),
              pickedDimm,
              pickedFade
            );
        }

        functions.updateGroups(
          pickedDimm,
          pickedFade,
          pickedColorHex,
          pickedChannels
        );

        functions.append(
          lights.split(splitter),
          pickedDimm,
          pickedFade,
          pickedColorHex,
          pickedChannels
        );
      }

      [
        allControlsTitle,
        allControlsColorInput,
        allControlsChannelInputs,
        allControlsQuickActions,
        allControlsDimmerInput,
        allControlsFadeInput,
        allControlsSubmit,
      ].forEach((a) => allControlsContainer.appendChild(a));

      document
        .querySelector("#lightcontrolsgroup")
        .appendChild(allControlsContainer);
    };

    static loadLiveUpdateToggle = () => {
      let liveUpdateContainer = document.createElement("div");
      liveUpdateContainer.id = "liveUpdateContainer";

      let liveUpdateTitle = document.createElement("h");
      liveUpdateTitle.id = "liveUpdateTitle";
      liveUpdateTitle.innerText = "Live Update";

      let liveUpdateCheckbox = document.createElement("input");
      liveUpdateCheckbox.type = "checkbox";

      liveUpdateCheckbox.onchange = () => {
        liveUpdate = liveUpdateCheckbox.checked;
        scripts.appendLiveUpdate();
      };

      [liveUpdateTitle, liveUpdateCheckbox].forEach((a) =>
        liveUpdateContainer.appendChild(a)
      );

      document.querySelector("body").appendChild(liveUpdateContainer);
    };

    static appendGroupToggle = () => {
      let groupToggleContainer = document.createElement("div");
      groupToggleContainer.id = "groupToggleContainer";

      let groupToggleTitle = document.createElement("h");
      groupToggleTitle.id = "groupToggleTitle";
      groupToggleTitle.innerText = "Show Groups";

      let groupToggleCheckbox = document.createElement("input");
      groupToggleCheckbox.type = "checkbox";
      groupToggleCheckbox.defaultChecked = true;

      groupToggleCheckbox.onchange = () => {
        groupToggle = groupToggleCheckbox.checked;
        scripts.appendGroupToggleUpdate();
      };

      [groupToggleTitle, groupToggleCheckbox].forEach((a) =>
        groupToggleContainer.appendChild(a)
      );

      document.querySelector("body").appendChild(groupToggleContainer);
    };

    static appendChannelsToggle = () => {
      let channelsToggleContainer = document.createElement("div");
      channelsToggleContainer.id = "channelsToggleContainer";

      let channelsToggleTitle = document.createElement("h");
      channelsToggleTitle.id = "groupToggleTitle";
      channelsToggleTitle.innerText = "Show Channels";

      let channelsToggleCheckbox = document.createElement("input");
      channelsToggleCheckbox.type = "checkbox";
      channelsToggleCheckbox.defaultChecked = true;

      channelsToggleCheckbox.onchange = () => {
        channelsToggle = channelsToggleCheckbox.checked;
        scripts.appendChannelsToggleUpdate();
      };

      [channelsToggleTitle, channelsToggleCheckbox].forEach((a) =>
        channelsToggleContainer.appendChild(a)
      );

      document.querySelector("body").appendChild(channelsToggleContainer);
    };

    static appendLiveUpdate = () => {
      let updateButtons = document.querySelectorAll(".controlsSubmit");
      updateButtons.forEach((a) => {
        if (liveUpdate) a.classList.add("hidden");
        else a.classList.remove("hidden");
      });

      let updateFades = document.querySelectorAll(".controlsFade");
      updateFades.forEach((a) => {
        if (liveUpdate) a.value = fadeLiveDefaultTime;
        else a.value = fadeDefaultTime;
      });
    };

    static appendGroupToggleUpdate = () => {
      let groupTitles = document.querySelectorAll(".controlsGroupTitle");
      groupTitles.forEach((a) => {
        if (!groupToggle) a.classList.add("hidden");
        else a.classList.remove("hidden");
      });
    };

    static appendChannelsToggleUpdate = () => {
      let channelsInputs = document.querySelectorAll(
        ".controlsChannelsContainer"
      );
      channelsInputs.forEach((a) => {
        if (!channelsToggle) a.classList.add("hidden");
        else a.classList.remove("hidden");
      });
    };

    static appendPresetSelector = () => {
      let presetContainer = document.createElement("div");
      presetContainer.id = "presetContainer";

      let presetSelector = document.createElement("select");
      presetSelector.id = "presetSelector";
      (() => {
        let defaultPreset = document.createElement("option");
        defaultPreset.innerText = "- Select Preset -";
        defaultPreset.value = "";
        defaultPreset.defaultSelected = true;
        defaultPreset.selected = true;
        presetSelector.appendChild(defaultPreset);

        presetSelector.onchange = (ev) => {
          let selectedPreset = presetSelector.value;
          appendPreset(selectedPreset);
        };
      })();

      function appendPreset(selectedPreset) {
        if (selectedPreset === "") return;
        console.debug("Selected preset", selectedPreset);

        let preset = functions.getPreset(selectedPreset);
        if (!preset)
          return console.error("preset not found by name", selectedPreset);

        let s = "";
        s += Object.values(preset.channels).join(presetEntrySplitter);
        s += Object.values(preset.groups).join(presetEntrySplitter);
        s +=
          preset.master ??
          Array(9)
            .map((a) => "")
            .join(presetChannelSplitter);

        if (s.length === 0)
          return console.error(`Not appending preset since it's empty`);

        functions.appendFromStrings(s);
      }

      let presetSave = document.createElement("button");
      (() => {
        presetSave.innerText = "Save";
        presetSave.onclick = () => {
          let presetNameDefault = `preset${
            Object.keys(functions.getPresets()).length + 1
          }`;
          let presetName =
            window.prompt("Preset Name", presetNameDefault) ??
            presetNameDefault;

          functions.setPreset(presetName, lightStates);

          this.appendPresets(presetName);
        };
      })();

      let presetDelete = document.createElement("button");
      (() => {
        presetDelete.innerText = "Delete";

        presetDelete.onclick = () => {
          functions.deletePreset(presetSelector.value);

          this.appendPresets();
        };
      })();

      let presetReload = document.createElement("button");
      (() => {
        presetReload.innerText = "Reload";

        presetReload.onclick = () => {
          appendPreset(presetSelector.value);
        };
      })();

      let presetRename = document.createElement("button");
      (() => {
        presetRename.innerText = "Rename";
        presetRename.onclick = () => {
          let presetNameOld = presetSelector.value;

          let preset = functions.getPreset(presetNameOld);

          let presetNameNew = window.prompt("New Preset name", presetNameOld);
          if (presetNameNew.length === 0 || presetNameOld === presetNameNew)
            return;

          functions.deletePreset(presetNameOld);
          functions.setPreset(presetNameNew, preset);

          this.appendPresets(presetNameNew);
        };
      })();

      let presetImport = document.createElement("button");
      (() => {
        presetImport.innerText = "Import";

        presetImport.onclick = () => {
          let presetNameDefault = `preset${
            Object.keys(functions.getPresets()).length + 1
          }`;

          let presetName =
            window.prompt("Preset Name", presetNameDefault) ??
            presetNameDefault;

          let presetRaw = window.prompt("Preset");
          if (!presetRaw) return;

          let preset;
          try {
            preset = JSON.parse(presetRaw);
          } catch (e) {
            return console.error("Preset not parseable as JSON");
          }

          functions.setPreset(presetName, preset);

          this.appendPresets(presetName);
        };
      })();

      let presetExport = document.createElement("button");
      (() => {
        presetExport.innerText = "Export";
        presetExport.onclick = () => {
          let presetName = presetSelector.value;
          let preset = functions.getPreset(presetName);

          if (!preset) return;

          navigator.clipboard.writeText(JSON.stringify(preset));
        };
      })();

      [
        presetSave,
        presetDelete,
        presetReload,
        presetRename,
        presetImport,
        presetExport,
      ].forEach((a) => {
        a.classList.add("presetButton");
      });

      [
        presetSelector,
        elements.br(),
        presetSave,
        presetDelete,
        presetReload,
        presetRename,
        elements.br(),
        presetImport,
        presetExport,
      ].forEach((a) => presetContainer.appendChild(a));

      document.querySelector("body").appendChild(presetContainer);

      scripts.appendPresets();
    };

    static appendRestartRefreshButtons = () => {
      let container = document.createElement("div");
      container.id = "restartRefreshContainer";

      let refreshButton = document.createElement("button");
      refreshButton.id = "refreshbutton";
      refreshButton.innerText = "Refresh";

      refreshButton.onclick = () => {
        ws.send("refresh");
      };

      let restartButton = document.createElement("button");
      restartButton.id = "restartbutton";
      restartButton.innerText = "Restart";

      restartButton.onclick = () => {
        ws.send("restart");
      };

      [refreshButton, restartButton].forEach((a) => container.appendChild(a));
      document.querySelector("body").appendChild(container);
    };

    static appendPresets = (selectPreset) => {
      let presetSelector = document.getElementById("presetSelector");
      [...presetSelector.childNodes].slice(1).forEach((a) => a.remove());

      let presets = functions.getPresets() ?? {};

      Object.keys(presets).forEach((preset) => {
        let presetElem = document.createElement("option");
        presetElem.innerText = preset;
        presetElem.value = preset;

        presetSelector.appendChild(presetElem);
      });

      if (selectPreset) presetSelector.value = selectPreset;
    };

    static appendEffect = () => {
      let effectContainer = document.createElement("div");
      effectContainer.id = "effectContainer";

      let effectStrobe = document.createElement("button");
      let effectFlash = document.createElement("button");
      // let effectOff = document.createElement("button");

      effectStrobe.innerText = "Strobe";
      effectFlash.innerText = "Flash";
      // effectOff.innerText = "Effect Off";

      let effectElems = [effectStrobe, effectFlash];
      let effectCommands = [
        ["strobe_on", "effect_off", "effectButton-strobe-active"],
        ["flash_on", "effect_off", "effectButton-flash-active"],
      ];
      let effectEnabled;

      [effectStrobe, effectFlash].forEach((a) => {
        a.setAttribute("state", "0");
        effectContainer.appendChild(a);
        a.classList.add("effectButton");

        a.onclick = () => {
          switch (a.getAttribute("state")) {
            case "0": {
              if (effectEnabled) return console.error("effect already enabled");
              a.setAttribute("state", "1");
              a.classList.add(effectCommands[effectElems.indexOf(a)][2]);
              effectElems
                .filter((b) => b !== a)
                .forEach((b) => {
                  b.setAttribute("disabled", true);
                });

              ws.send(effectCommands[effectElems.indexOf(a)][0]);
              effectEnabled = a;
              break;
            }

            case "1": {
              if (!effectEnabled) return console.error("effect not enabled");
              a.setAttribute("state", "0");
              a.classList.remove(effectCommands[effectElems.indexOf(a)][2]);
              effectElems
                .filter((b) => b !== a)
                .forEach((b) => {
                  b.removeAttribute("disabled");
                });
              ws.send(effectCommands[effectElems.indexOf(a)][1]);
              effectEnabled = undefined;
              break;
            }
          }
        };
      });

      document.querySelector("body").appendChild(effectContainer);
    };
  }

  class elements {
    static br = () => {
      return document.createElement("br");
    };
    static spacer = () => {
      return document.createElement("spacer");
    };

    static controlsColorInput = (containerID) => {
      let controlsColorPickerContainer = document.createElement("div");
      controlsColorPickerContainer.classList.add(
        "controlsColorPickerContainer"
      );

      let controlsColorPickerTitle = document.createElement("h");
      controlsColorPickerTitle.innerText = "Color Picker";

      let controlsColorPicker = document.createElement("input");
      if (containerID) controlsColorPicker.id = `${containerID}-color`;
      controlsColorPicker.classList.add("controlsColorInput");
      controlsColorPicker.type = "color";
      controlsColorPicker.defaultValue = "#000000";

      [controlsColorPickerTitle, controlsColorPicker].forEach((a) =>
        controlsColorPickerContainer.appendChild(a)
      );

      return controlsColorPickerContainer;
    };

    static controlsChannelInputs = (containerID) => {
      let channelsContainer = document.createElement("div");
      channelsContainer.classList.add("controlsChannelsContainer");

      let channelsContainerInner = document.createElement("div");

      let channelsTitle = document.createElement("h");
      channelsTitle.innerText = "Channels";

      let channelsInputContainer = document.createElement("div");
      if (containerID) channelsInputContainer.id = `${containerID}-channels`;
      channelsInputContainer.classList.add("controlsChannelsInputContainer");

      let channelTitlesContainer = document.createElement("div");
      if (containerID)
        channelTitlesContainer.id = `${containerID}-channel-titles`;
      channelTitlesContainer.classList.add("controlsChannelTitlesContainer");

      RGBchannels.forEach((channel) => {
        let channelInput = document.createElement("input");
        if (containerID)
          channelInput.id = `${channelsInputContainer.id}-${channel[1]}`;
        channelInput.classList.add(
          "controlsChannelInput",
          `controlsChannel-${channel[1]}`,
          "vertical"
        );
        channelInput.type = "range";
        channelInput.style.backgroundColor = channel[2];
        channelInput.min = rangeInputMin;
        channelInput.max = rangeInputMax;
        channelInput.defaultValue = channel[3];

        let channelTitle = document.createElement("h");
        channelTitle.classList.add("controlsChannelTitle");
        channelTitle.title = channel[0];
        channelTitle.innerText = channel[1];

        channelsInputContainer.appendChild(channelInput);
        channelTitlesContainer.appendChild(channelTitle);
      });

      [
        channelsTitle,
        channelsInputContainer,
        channelTitlesContainer,
      ].forEach((a) => channelsContainerInner.appendChild(a));
      channelsContainer.appendChild(channelsContainerInner);

      return channelsContainer;
    };

    static controlsDimmerInput = (containerID) => {
      let controlsDimmerContainer = document.createElement("div");
      controlsDimmerContainer.classList.add("controlsDimmerContainer");

      let controlsDimmerContainerInner = document.createElement("div");

      let controlsDimmerTitle = document.createElement("h");
      controlsDimmerTitle.innerText = "Dimmer";

      let controlsDimmerInput = document.createElement("input");
      if (containerID) controlsDimmerInput.id = `${containerID}-dimm`;

      controlsDimmerInput.classList.add("dimmer");
      controlsDimmerInput.classList.add("controlsDimmerInput", "horizontal");
      controlsDimmerInput.type = "range";
      controlsDimmerInput.min = rangeInputMin;
      controlsDimmerInput.max = 100;
      controlsDimmerInput.defaultValue = rangeInputDefault;

      [controlsDimmerTitle, controlsDimmerInput].forEach((a) =>
        controlsDimmerContainerInner.appendChild(a)
      );
      controlsDimmerContainer.appendChild(controlsDimmerContainerInner);

      return controlsDimmerContainer;
    };

    static controlsFadeInput = (containerID) => {
      let fadeContainer = document.createElement("div");
      fadeContainer.classList.add("controlsFadeContainer");

      let fadeContainerInner = document.createElement("div");

      let fadeTitle = document.createElement("h");
      fadeTitle.innerText = "Fade";

      let fadeInput = document.createElement("input");
      fadeInput.id = `${containerID}-fade`;
      fadeInput.classList.add("controlsFadeInput", "horizontal");
      fadeInput.type = "range";
      fadeInput.min = fadeRangeMin;
      fadeInput.max = fadeRangeMax;
      fadeInput.defaultValue = fadeRangeDefault;

      [fadeTitle, fadeInput].forEach((a) => fadeContainerInner.appendChild(a));
      fadeContainer.appendChild(fadeContainerInner);

      return fadeContainer;
    };

    static controlsQuickActions = (containerID, groupName, append) => {
      let actionGroup = () => {
        return groupName?.() ?? "_all";
      };
      let quickActionsContainer = document.createElement("div");
      quickActionsContainer.classList.add("controlsQuickActionsContainer");

      let quickActionsFullon = document.createElement("button");
      let quickActionsFulloff = document.createElement("button");
      let quickActionsHold = document.createElement("button");

      quickActionsFullon.innerText = "Full On";
      quickActionsFulloff.innerText = "Full Off";
      quickActionsHold.innerText = "Hold";

      function createQuickStates() {
        if (!quickStates[actionGroup()])
          quickStates[actionGroup()] = {
            fullOn: 0,
            fullOff: 0,
            isHeld: 0,
            heldActions: [],
          };
      }

      function setQuickState(a, v) {
        switch (a) {
          case "fullOn": {
            quickStates[actionGroup()].fullOn = v;
            quickStates[actionGroup()].fullOff = 2;
            break;
          }

          case "fullOff": {
            quickStates[actionGroup()].fullOff = v;
            quickStates[actionGroup()].fullOn = 2;
            break;
          }

          case "isHeld": {
            quickStates[actionGroup()].isHeld = v;
            break;
          }
        }
      }

      function quickButtonChanger(ev) {
        createQuickStates();
        let quickButtonNames = ["fullOn", "fullOff", "isHeld"];
        let quickButtons = [
          quickActionsFullon,
          quickActionsFulloff,
          quickActionsHold,
        ];
        let quickButtonIndex = quickButtons.indexOf(ev.target);
        let quickButtonOthers = [...quickButtons].filter(
          (a) => a !== ev.target
        );
        let quickButton = quickButtons[quickButtonIndex];
        let tag = quickButtonNames[quickButtonIndex];
        let state = functions.getQuickState(actionGroup(), tag);
        switch (state) {
          case 0:
          case 2: {
            functions.quickButtonActive(quickButton);

            setQuickState(tag, 1);

            switch (quickButtonNames[quickButtonIndex]) {
              case "fullOn":
              case "fullOff": {
                append(false, false, false, [
                  [0, 0, 0, [255, 0][quickButtonIndex], 0, 0],
                  [[255, 0][quickButtonIndex], 0, 0, 0, 0, 0],
                ]);
                break;
              }
            }
            break;
          }

          case 1: {
            functions.quickButtonInactive(quickButton);
            setQuickState(tag, 0);

            switch (quickButtonNames[quickButtonIndex]) {
              case "isHeld": {
                functions.appendHeld(groupName);
                break;
              }
            }
            break;
          }
        }

        switch (quickButtonNames[quickButtons.indexOf(quickButton)]) {
          case "fullOn":
          case "fullOff": {
            quickButtonOthers
              .filter((a) => a !== quickActionsHold)
              .forEach((a) => {
                functions.quickButtonInactive(a);
              });

            return;
          }

          case "isHeld": {
            quickButtonOthers.forEach((a) => {
              [functions.disableElem, functions.enableElem][state]?.(a);
              functions.quickButtonInactive(a);
              setQuickState(quickButtonNames[quickButtons.indexOf(a)], 2);
            });

            return;
          }
        }
      }

      [quickActionsFullon, quickActionsFulloff, quickActionsHold].map((a) => {
        a.classList.add("quickActionButton");
        quickActionsContainer.appendChild(a);
        a.onclick = quickButtonChanger;
      });

      return quickActionsContainer;
    };
  }

  elementsLoaded = new Promise((resolve) => {
    scripts.loadLights();
    scripts.loadLightGroups();
    scripts.loadLightAll();
    scripts.loadLiveUpdateToggle();
    scripts.appendGroupToggle();
    scripts.appendChannelsToggle();
    scripts.appendPresetSelector();
    scripts.appendRestartRefreshButtons();
    scripts.appendEffect();
    resolve();
    elementsLoaded = undefined;
  });

  // const ws = new WebSocket(`ws://127.0.0.1:81`);
  const ws = new WebSocket(`ws://${window.location.hostname}/ws`);
  try {
    ws.onopen = () => {
      console.log("WS Opened");
    };
    ws.onmessage = async (m) => {
      if (elementsLoaded) await elementsLoaded;
      handleWSMessage(m);
    };

    function handleWSMessage(m) {
      let msg = m.data;
      if (msg.startsWith("refresh")) {
        functions.appendFromStrings(msg.replace(/^refresh;/, ""));
        console.debug(`WS: Refresh appended`);
      }
    }
    ws.onerror = (e) => {
      console.error("WS Error", e);
    };
    ws.onclose = () => {
      window.alert(
        "WebSocket connection lost - further updates will not be sent" +
          "\n\nTo reconnect, make sure the lightcontroller is turned on and you are connected via WiFi"
      );
    };
  } catch (e) {
    console.error(e);
  }
</script>
<style>
  * {
    scrollbar-width: thin;
    font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande",
      "Lucida Sans", Arial, sans-serif;
    border-radius: 10px;
    /* word-break: normal; */
    /* line-break: anywhere; */
    text-align: center;
    user-select: none;
    padding: 3px;
  }

  .hidden {
    display: none !important;
  }

  button,
  input[type="checkbox"] {
    cursor: pointer;
  }

  @media screen and (-webkit-min-device-pixel-ratio: 0) {
    .controlsChannelInput {
      overflow: hidden;
      /* width: 80px; */
      appearance: none;
      -webkit-appearance: none;
      background-color: #fff;
      border: 1px solid;
    }

    .controlsChannelInput::-webkit-slider-runnable-track {
      height: 10px;
      appearance: none;
      -webkit-appearance: none;
      color: #fff;
      background-color: transparent;
      margin-top: -1px;
    }

    .controlsChannelInput::-webkit-slider-thumb {
      width: 10px;
      -webkit-appearance: none;
      height: 10px;
      border: 1px solid white;
      border-radius: 100%;
      background: transparent;
      /* box-shadow: -87px 0 2px 90px #fcca46; */
      box-shadow: 396px 0 2px 400px #000000;
    }
  }

  .horizontal {
    cursor: w-resize;
  }

  .vertical {
    cursor: n-resize;
  }

  .controlsChannelInput {
    border: 1px solid white;
    background-color: #000000;
  }

  .controlsChannelInput::-moz-range-progress {
    background-color: #fcca46;
  }

  .controlsChannelInput::-moz-range-track {
    background-color: #000000;
  }

  /* .dimmer {
        background-color: white;
    } */

  body {
    background-color: #233d4d;
    transition: ease-in 2s;
    color: #f1faee;
    padding: 3px;
  }

  #lightcontrols,
  #lightcontrolsgroup {
    display: flex;
    place-items: center;
    flex-wrap: wrap;
    justify-content: center;
    /* align-items: stretch; */
    align-items: flex-start;
  }

  #lightcontrolsgroup {
    align-items: stretch;
  }

  .controlsContainer {
    display: flex;
    flex: 1 0 24%;
  }

  .controlsContainer,
  .groupControlsContainer {
    max-width: 23%;
    padding: 6px;
    margin: 2px;
    width: 25%;
    gap: 3px;
    border: 1px solid;
    background-color: #1d2d44;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-evenly;
  }

  /* #lightcontrolsgroup {
        display: flex;
        justify-content: center;
    } */

  .groupControlsContainer {
    max-width: none;
    width: 40%;
  }

  spacer {
    display: flex;
    height: 10px;
  }

  .controlsTitle {
    font-size: large;
    height: 50%;
    /* word-break: break-all; */
  }

  .controlsDimmerInput,
  .controlsFadeInput {
    width: 80%;
  }

  .controlsColorInput,
  .controlsSubmit {
    border: none;
    outline: none;
  }

  .controlsSelector {
    border: 1px solid transparent;
  }

  .controlsColorInput {
    background-color: transparent;
    box-sizing: content-box;
    padding: 0;
    height: 30px;
  }

  .controlsSubmit {
    padding: 4px;
  }

  .controlsGroupTitle {
    font-size: small;
    overflow-y: auto;
    height: 50%;
    /* word-break: break-all; */
  }

  .controlsColorPickerContainer,
  .controlsChannelsContainer,
  .controlsDimmerContainer,
  .controlsFadeContainer,
  .controlsQuickActionsContainer {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    border: 1px solid;

    flex-direction: column;
    width: 100%;
  }

  .controlsDimmerContainer > div,
  .controlsFadeContainer > div {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 90%;
  }

  .controlsQuickActionsContainer {
    flex-direction: row;
  }

  @media screen and (max-width: 700px) {
    .controlsChannelsContainer {
      display: none;
    }
  }

  .controlsChannelsContainer {
    flex-direction: column;
    flex-wrap: nowrap;
    /* height: 218px; */
  }

  /* .controlsColorPickerContainer { */
  /* min-width: 205px; */
  /* } */

  .controlsChannelsInputContainer {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    flex-direction: column;
    transform: rotate(-90deg);
    row-gap: 1px;
    /* row-gap: 7.5px; */
    /* min-width: 160px; */
    /* width: min-content; */
    justify-content: center;
    aspect-ratio: 1/1.2;
  }

  .controlsChannelTitle {
    /* display: flex; */
    cursor: help;
  }

  .controlsChannelTitlesContainer {
    display: flex;
    /* gap: 10px; */
    justify-content: space-evenly;
  }

  .controlsColorPickerContainer {
    flex-direction: column;
    justify-content: center;
  }

  #liveUpdateContainer {
    background-color: #38a3a5;
    z-index: 10;
    position: absolute;
    left: 10px;
    top: 40px;
  }

  #groupToggleContainer {
    background-color: #38a3a5;
    z-index: 10;
    position: absolute;
    left: 10px;
    top: 10px;
  }

  #presetContainer {
    z-index: 10;
    position: absolute;
    /* left: 0; */
    right: 10px;
    top: 5px;
  }

  #presetContainer select {
    width: 100%;
  }

  #presetContainer button {
    border: transparent;
    margin: 2px;
  }

  #presetContainer select {
    border: transparent;
    background-color: #38a3a5;
  }

  #channelsToggleContainer {
    background-color: #38a3a5;
    z-index: 10;
    position: absolute;
    left: 150px;
    top: 10px;
  }

  .effectButton,
  .quickActionButton {
    display: flex;
    border-radius: 6px;
    border: 1px solid #f1faee;
    margin: 2px;
    background-color: #220901;
    color: #f1faee;
  }

  .effectButton:disabled,
  .quickActionButton:disabled {
    color: grey;
  }

  @keyframes blink {
    0%,
    49% {
      background-color: red;
      color: black;
    }

    50%,
    99% {
      background-color: #220901;
      /* color: #f1faee; */
      color: red;
    }
  }

  .quickActionButton-active {
    background-color: #a1c181;
    animation: blink 1s infinite;
  }

  .controlsContainerTop,
  .controlsContainerBottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    /* justify-content: space-evenly; */
    margin: 0;
    padding: 0;
    width: 100%;
    gap: 2px;
  }

  .controlsContainerTop {
    height: 45%;
  }

  .controlsContainerTop {
    height: 55%;
  }

  .empty {
    background: transparent;
    border: transparent;
  }

  #restartRefreshContainer {
    position: absolute;
    top: 5px;
    left: 0;
    right: 0;
  }

  #restartRefreshContainer button {
    border: transparent;
    margin: 3px;
    background-color: red;
  }

  #effectContainer {
    display: flex;
    position: absolute;
    flex-wrap: nowrap;
    top: 5px;
    left: 65vw;
  }

  @keyframes effectStrobeActive {
    0%,
    30% {
      background-color: #f00;
      color: black;
    }

    33%,
    63% {
      background-color: #0f0;
      color: black;
    }

    66%,
    100% {
      background-color: #00f;
      color: white;
    }
  }

  @keyframes effectFlashActive {
    0% {
      background-color: black;
      color: white;
    }
    100% {
      background-color: #fff;
      color: black;
    }
  }

  .effectButton-strobe-active {
    animation: effectStrobeActive 1s infinite;
  }

  .effectButton-flash-active {
    animation: effectFlashActive 200ms infinite;
  }
</style>
