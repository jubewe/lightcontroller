<!-- Welcome to the Frontend -->
<!-- https://github.com/jubewe/lightcontroller -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lightcontroller</title>
  </head>

  <body>
    <h3>Lightcontroller</h3>
    <div id="lightcontrols"></div>
    <div id="lightcontrolsgroup"></div>
  </body>

  <footer>
    <h>This Controller was made by</h>
    <a href="https://github.com/jubewe">Julian (Frontend)</a>
    <a href="https://github.com/jojo-06">Johannes (PCB + Backend)</a>
    <a href="https://github.com/jubewe/lightcontroller"
      >Documentation (GitHub)</a
    >
  </footer>
</html>
<script>
  const url = new URL(document.baseURI);

  // const lights = "{{CONFIG}}";
  /* const lights = "Left Top;1;6;Spots,Spots Left,Left---Left Bottom;7;6;Spots,Spots Left,Left---Right Top;13;6;Spots,Spots Right,Right---Right Bottom;19;6;Spots,Spots Right,Right"; */
  const splitter = "---";
  const lights =
    "Bühne Links Außen Hinten;1;1;Bühne,Links,Bühne Links,Bühne Hinten,Bühne Außen,Bühne Links Außen,Bühne Links Hinten---Bühne Links Innen Hinten;7;1;Bühne,Links,Bühne Links,Bühne Hinten,Bühne Innen,Bühne Links Innen,Bühne Links Hinten---Bühne Rechts Innen Hinten;13;1;Bühne,Rechts,Bühne Rechts,Bühne Hinten,Bühne Innen,Bühne Rechts Innen,Bühne Rechts Hinten---Bühne Rechts Außen Hinten;19;1;Bühne,Rechts,Bühne Rechts,Bühne Hinten,Bühne Außen,Bühne Rechts Außen,Bühne Rechts Hinten---Bühne Links Außen Vorne;25;1;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Außen,Bühne Links Außen,Bühne Links Vorne---Bühne Links Innen Vorne;31;1;Bühne,Links,Bühne Links,Bühne Vorne,Bühne Innen,Bühne Links Innen,Bühne Links Vorne---Bühne Rechts Innen Vorne;37;1;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Innen,Bühne Rechts Innen,Bühne Rechts Vorne---Bühne Rechts Außen Vorne;43;1;Bühne,Rechts,Bühne Rechts,Bühne Vorne,Bühne Außen,Bühne Rechts Außen,Bühne Rechts Vorne---Spot Links Oben;49;6;Spots,Spots Links,Spots Oben,Links---Spot Links Unten;55;6;Spots,Spots Links,Spots Unten,Links---Spot Rechts Oben;61;6;Spots,Spots Rechts,Spots Oben,Rechts---Spot Rechts Unten;67;6;Spots,Spots Rechts,Spots Unten,Rechts";
  console.debug("Loaded config", lights);
  const channels = [
    ["Red", "r", "#ff0000", 0],
    ["Green", "g", "#00ff00", 0],
    ["Blue", "b", "#0000ff", 0],
    ["White", "w", "#ffffff", 255],
    ["Amber", "a", "#ffbf00", 0],
    ["UV", "u", "#5f4b8b", 0],
  ];

  const rangeInputMin = 0;
  const rangeInputMax = 255;
  const rangeInputDefault = 0;

  const fadeRangeMin = 0;
  const fadeRangeMax = 30; /* seconds, gets converted into milliseconds */
  const fadeRangeDefault = 0;
  const fadeDefaultTime = 1;
  const fadeLiveDefaultTime = 0;

  const channelsPerRGBLight = 6;
  let groups = {};
  let liveUpdate = false;
  let groupToggle = true;

  let fullOn = 0;
  let fullOff = 0;
  let quickStates = {
    fullOn: {
      _all: 0,
    },
    fullOff: {
      _all: 0,
    },
  };
  // 0 = disabled, 1 = active, 2 = overridden by other mode
  lights.split(splitter).forEach((line) => {
    let splits = line.split(";");
    let groups_ = splits[3];
    if (groups_.length === 0) return;
    groups_.split(",").forEach((group) => {
      if (!groups[encodeURI(group)]) groups[encodeURI(group)] = [];
      groups[encodeURI(group)].push(line);
    });
  });

  console.debug("Groups", groups);

  const ws = new WebSocket(`ws://127.0.0.1:81`);
  // const ws = new WebSocket(`ws://${window.location.hostname}/ws`);
  try {
    ws.onopen = () => {
      console.log("WS Opened");
    };
    ws.onmessage = (m) => {
      console.log("WS Message", m);
    };
    ws.onerror = (e) => {
      console.error("WS Error", e);
    };
  } catch (e) {
    console.error(e);
  }

  class functions {
    static request = (u, options) => {
      return new Promise((resolve, reject) => {
        if (!/^http(s)*:\/{2}/i.test(u)) u = url.origin + u;
        options = options ?? {};

        fetch(u, options)
          .then((v) => {
            resolve(v.body);
          })
          .catch(reject);
      });
    };

    static submitConfig = (config) => {
      this.request("/config", {
        headers: {
          plain: typeof config !== "string" ? JSON.stringify(config) : config,
        },
        method: "POST",
      })
        .then(() => {
          console.debug("POST Config Success");
        })
        .catch((e) => {
          console.error("POST Config error", e);
        });
    };

    static getWhite = (hex) => {
      if (hex.replace(/^#/, "").toLowerCase() === "ffffff") return 255;
      return 0;
    };

    static hexToRGBParsed = (hex) => {
      /* let w = functions.getWhite(hex);
                  let rgb = functions.hexToRGB(hex); */
      return functions.hexToRGB(hex);

      // let r = {
      //     /* ...(w === 255 ? { r: 0, g: 0, b: 0 } : rgb),
      //     w: w */
      // };

      // return r;
    };

    static hexToRGB = (hex) => {
      let r = {};
      let hexParts = hex.replace(/^#/, "").match(/\w{2}/g);
      hexParts.forEach((a, i) => (r[["r", "g", "b"][i]] = parseInt(a, 16)));
      return r;
    };

    static RGBToHex = (r, g, b, w) => {
      let hex = "#";
      /* if (w && (w == 255)) return "#ffffff"; */
      hex += functions.pad2(Math.abs(r).toString(16));
      hex += functions.pad2(Math.abs(g).toString(16));
      hex += functions.pad2(Math.abs(b).toString(16));
      return hex;
    };

    static pad2 = (n) => {
      if (!/^\d$/.test(n)) return `${n.length < 2 ? "0" : ""}${n}`;
      return `${parseInt(n) < 10 ? "0" : ""}${n}`;
    };

    static getValuesFromChannels = (containerID) => {
      let r = {};
      channels.forEach((channel) => {
        r[channel[1]] = document.getElementById(
          `${containerID}-channels-${channel[1]}`
        ).value;
      });
      return r;
    };

    static appendValuesFromChannels = (containerID) => {
      let vals = functions.getValuesFromChannels(containerID);
      let [r, g, b] = [vals.r, vals.g, vals.b];
      let hex = functions.RGBToHex(r, g, b);
      document.getElementById(`${containerID}-color`).value = hex;
      return hex;
    };

    static appendHexToChannels = (containerID, hex) => {
      let hex_ = hex ?? document.getElementById(`${containerID}-color`).value;
      let rgbw = functions.hexToRGBParsed(hex_);

      let r = {};
      Object.keys(rgbw).forEach((channel) => {
        document.getElementById(`${containerID}-channels-${channel}`).value =
          rgbw[channel];
        r[channel] = rgbw[channel];
      });
      return r;
    };

    static appendToChannels = (containerID, pickedChannels) => {
      Object.keys(pickedChannels).forEach((channel) => {
        document.getElementById(`${containerID}-channels-${channel}`).value =
          pickedChannels[channel];
      });
    };

    static parseWSUpdateMessage = (addr, dimm, r, g, b, w, a, u, fade) => {
      let args = [addr, r, g, b, w, a, u, (fade ?? 0) * 1000];
      let argsParsed = [
        addr,
        ...args
          .slice(1, 7)
          .map((arg) => Math.floor(parseInt(arg) * (1 - (dimm ?? 0) / 100))),
        fade * 1000,
      ];
      return [].concat(argsParsed, Array(8).slice(0, 8 - argsParsed.length));
    };

    static updateLight = (addr, dimm, r, g, b, w, a, u, fade) => {
      let msg = this.parseWSUpdateMessage(addr, dimm, r, g, b, w, a, u, fade);
      console.debug("WS Update RGB", msg.join(";"));
      ws?.send(msg.join(";"));
    };

    static parseWSUpdateMessagenoRGB(addr, dimm, fade) {
      return [
        addr,
        Math.floor(255 * (1 - dimm / 100)),
        ...[...Array(5)].map((a) => 0),
        fade * 1000,
      ];
    }

    static updateLightnoRGB = (addr, dimm, fade) => {
      console.debug(
        "WS Update Non-RGB",
        [
          addr,
          Math.floor(255 * (1 - dimm / 100)),
          ...[...Array(5)].map((a) => 0),
          fade * 1000,
        ].join(";")
      );
      ws?.send(this.parseWSUpdateMessagenoRGB(addr, dimm, fade).join(";"));
    };

    static updateLightVal = (addr, vals, fade) => {
      let vals_ = vals;
      if (!Array.isArray(vals_)) vals_ = [...Array(6)].map((a) => vals);
      console.debug("WS Update Val", [addr, ...vals_, fade * 1000].join(";"));

      let rgbChans = ws?.send([addr, ...vals_, fade * 1000].join(";"));
    };

    static quickButtonActive = (elem) => {
      elem.classList.add("quickActionButton-active");
      // elem.setAttribute("state", "1");
    };

    static quickButtonInactive = (elem) => {
      elem.classList.remove("quickActionButton-active");
      // elem.setAttribute("state", "0");
    };

    static getQuickState = (ag, a) => {
      return quickStates[ag]?.[a] ?? 0;
    };

    static appendHeld = (groupName) => {
      let held = quickStates[groupName()];
      if (!held?.heldActions) return;
      let updatesRGB = [];
      let updatesnoRGB = [];

      /*
      let appendActions = {
        channels: [[], [], [], [], [], []],
        addresses: {},
      };

      held.heldActions.forEach((heldAction) => {
        if (heldAction[0].length === 0) return;

        let addresses = heldAction[0];
        addresses.forEach((address) => {
          appendActions.addresses[address] = heldAction.slice(1, 7);
        });
      });

      // Object.keys(appendActions.addresses).forEach((address) => {
      //   let channels = appendActions.addresses[address];

      //   channels.forEach((channel, i) => {
      //     let channelName = Object.keys(appendActions.channels)[i];

      //     if (!appendActions.channels[i].filter((a) => a[0] === channel)[0])
      //       appendActions.channels[i].push([channel, []]);

      //     appendActions.channels[i]
      //       .filter((a) => a[0] === channel)[0][1]
      //       .push(address);
      //   });
      // });

      // appendActions.channels.forEach((channel) => {
      //   channel.forEach((update) => {
      //     updates.push([update[1].join(","),]);
      //   });
      // });
      */

      held.heldActions.reverse().forEach((a) => {
        let rgbUpdates = a[0];
        let norgbUpdates = a[1];

        function append(b, c) {
          if (
            b[0].length === 0 ||
            c.filter((d) => d[0].join(";") === b[0].join(";"))[0]
          )
            return;

          c.push(b);
        }

        append(rgbUpdates, updatesRGB);
        append(norgbUpdates, updatesnoRGB);
      });

      updatesRGB.forEach((a) => {
        functions.updateLight(...a);
      });

      updatesnoRGB.forEach((a) => {
        functions.updateLightnoRGB(...a);
      });

      held.heldActions = [];
    };

    static disableElem = (elem) => {
      elem.disabled = true;
    };

    static enableElem = (elem) => {
      elem.removeAttribute("disabled");
    };
  }

  class scripts {
    static loadLights = () => {
      lights.split(splitter).forEach((line, i) => {
        let [
          lightName,
          lightDmxAddress,
          lightChannels,
          lightGroupName,
        ] = line.split(";");
        let isRGB = parseInt(lightChannels) > 1;

        let controlsContainer = document.createElement("div");
        controlsContainer.id = `controls${lightDmxAddress}`;
        controlsContainer.classList.add("controlsContainer");

        let controlsContainerTop = document.createElement("div");
        controlsContainerTop.classList.add("controlsContainerTop");

        let controlsContainerBottom = document.createElement("div");
        controlsContainerBottom.classList.add("controlsContainerBottom");

        let controlsTitle = document.createElement("h");
        controlsTitle.classList.add("controlsTitle");
        controlsTitle.innerText = lightName;

        let controlsGroupTitle = document.createElement("h");
        controlsGroupTitle.classList.add("controlsGroupTitle");
        controlsGroupTitle.innerText = lightGroupName.split(",").join(", ");

        let controlsColorInput = elements.controlsColorInput(
          controlsContainer.id
        );
        let controlsChannelInputs = elements.controlsChannelInputs(
          controlsContainer.id
        );
        let controlsDimmerInput = elements.controlsDimmerInput(
          controlsContainer.id
        );
        let controlsFadeInput = elements.controlsFadeInput(
          controlsContainer.id
        );

        controlsColorInput.onchange = () => {
          append();
          functions.appendHexToChannels(controlsContainer.id);
        };
        controlsChannelInputs.onchange = () => {
          append();
          functions.appendValuesFromChannels(controlsContainer.id);
        };
        controlsDimmerInput.onchange = () => {
          append();
        };
        controlsFadeInput.onchange = () => {
          append();
        };

        let controlsSubmit = document.createElement("button");
        controlsSubmit.innerText = "Update";
        controlsSubmit.classList.add("controlsSubmit");
        controlsSubmit.onclick = () => {
          append(true);
        };

        function append(update) {
          let pickedDimm = controlsDimmerInput.querySelector(
            ".controlsDimmerInput"
          ).value;
          let pickedFade = controlsFadeInput.querySelector(".controlsFadeInput")
            .value;

          let isOverridden =
            functions.getQuickState("_all", "fullOn") === 1 ||
            functions.getQuickState("_all", "fullOff") === 1;

          let isHeld = functions.getQuickState("_all", "isHeld") === 1;

          if (!isRGB) {
            if (isHeld) {
              quickStates._all.heldActions.push([
                [],
                [[lightDmxAddress], pickedDimm, pickedFade],
              ]);

              return;
            }

            if ((update || liveUpdate) && !isOverridden)
              functions.updateLightnoRGB(
                lightDmxAddress,
                pickedDimm,
                pickedFade
              );
            return;
          }

          let pickedColorHex = controlsColorInput.querySelector(
            ".controlsColorInput"
          ).value;
          let pickedColor = functions.hexToRGBParsed(pickedColorHex);
          let pickedChannels = functions.getValuesFromChannels(
            controlsContainer.id
          );

          if (isHeld) {
            quickStates._all.heldActions.push([
              [
                [lightDmxAddress],
                pickedDimm,
                ...Object.values(pickedChannels),
                pickedFade,
              ],
              [],
            ]);

            return;
          }

          if ((update || liveUpdate) && !isOverridden)
            functions.updateLight(
              lightDmxAddress,
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade
            );
        }

        [controlsTitle, controlsGroupTitle].map((a) =>
          controlsContainerTop.appendChild(a)
        );
        [
          ...(isRGB ? [controlsColorInput, controlsChannelInputs] : []),
          controlsDimmerInput,
          controlsFadeInput,
          controlsSubmit,
        ].forEach((a) => controlsContainerBottom.appendChild(a));
        [controlsContainerTop, controlsContainerBottom].map((a) =>
          controlsContainer.appendChild(a)
        );

        document.querySelector("#lightcontrols").appendChild(controlsContainer);
      });
    };

    static loadLightGroups = () => {
      let groupControlsContainer = document.createElement("div");
      groupControlsContainer.classList.add("groupControlsContainer");
      groupControlsContainer.id = "controlsGroup";

      let groupControlsTitle = document.createElement("h");
      groupControlsTitle.innerText = "Group Controls";
      groupControlsTitle.classList.add("controlsTitle");

      let groupSelector = document.createElement("select");
      groupSelector.classList.add("controlsSelector");
      Object.keys(groups).forEach((group) => {
        let groupOption = document.createElement("option");
        groupOption.innerText = decodeURI(group);
        groupOption.value = group;
        groupSelector.appendChild(groupOption);
      });

      let groupControlsColorInput = elements.controlsColorInput(
        groupControlsContainer.id
      );
      let groupControlsChannelInputs = elements.controlsChannelInputs(
        groupControlsContainer.id
      );
      let groupName = () => {
        return `_group_${groupSelector.value}`;
      };
      let groupControlsQuickActions = elements.controlsQuickActions(
        groupControlsContainer.id,
        groupName,
        append
      );
      let groupControlsDimmerInput = elements.controlsDimmerInput(
        groupControlsContainer.id
      );
      let groupControlsFadeInput = elements.controlsFadeInput(
        groupControlsContainer.id
      );

      let groupControlsSubmit = document.createElement("button");
      groupControlsSubmit.innerText = "Update";
      groupControlsSubmit.classList.add("controlsSubmit");

      groupControlsSubmit.onclick = () => {
        append(true);
      };
      groupControlsColorInput.onchange = () => {
        append(false, true, false);
      };
      groupControlsChannelInputs.onchange = () => {
        append(false, false, true);
      };
      groupControlsDimmerInput.onchange = () => {
        append();
      };
      groupControlsFadeInput.onchange = () => {
        append();
      };

      function append(update, fromPicker, fromChannels, quickOverrideVal) {
        let pickedColorHex = groupControlsColorInput.querySelector(
          ".controlsColorInput"
        ).value;
        let pickedDimm = groupControlsDimmerInput.querySelector(
          ".controlsDimmerInput"
        ).value;
        let pickedFade = groupControlsFadeInput.querySelector(
          ".controlsFadeInput"
        ).value;

        let pickedGroup = groupSelector.value;

        if (fromPicker)
          functions.appendHexToChannels(
            groupControlsContainer.id,
            pickedColorHex
          );
        if (fromChannels)
          pickedColorHex = functions.appendValuesFromChannels(
            groupControlsContainer.id
          );
        let pickedChannels = functions.getValuesFromChannels(
          groupControlsContainer.id
        );

        let isOverridden =
          functions.getQuickState(groupName(), "fullOn") === 1 ||
          functions.getQuickState(groupName(), "fullOff") === 1;

        let isHeld = functions.getQuickState(groupName(), "isHeld") === 1;

        let rgbChans = groups[pickedGroup]
          .filter((a) => parseInt(a.split(";")[2]) > 1)
          .map((a) => a.split(";")[1]);

        let noRGBChans = groups[pickedGroup]
          .filter((a) => parseInt(a.split(";")[2]) === 1)
          .map((a) => a.split(";")[1]);

        if (isHeld)
          return quickStates[groupName()].heldActions.push([
            [
              rgbChans,
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade,
            ],

            [noRGBChans, pickedDimm, pickedFade],
          ]);

        if (quickOverrideVal) {
          functions.updateLightVal(rgbChans, quickOverrideVal[0], 0);
          functions.updateLightVal(noRGBChans, quickOverrideVal[1], 0);
        } else if ((update || liveUpdate) && !isOverridden) {
          if (rgbChans.length > 0)
            functions.updateLight(
              rgbChans.join(","),
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade
            );

          if (noRGBChans.length > 0)
            functions.updateLightnoRGB(
              noRGBChans.join(","),
              pickedDimm,
              pickedFade
            );
        }

        groups[pickedGroup]
          .map((a) => a.split(";")[1])
          .forEach((light) => {
            let l = lights
              .split(splitter)
              .filter((a) => a.split(";")[1] === light)[0]
              ?.split(";");
            let i = l?.[1];

            if (i === undefined) return;
            if (!document.getElementById(`controls${i}`)) return;
            let isRGB = parseInt(l[2]) > 1;
            document.getElementById(`controls${i}-dimm`).value = pickedDimm;
            document.getElementById(`controls${i}-fade`).value = pickedFade;
            if (!isRGB) return;
            document.getElementById(
              `controls${i}-color`
            ).value = pickedColorHex;
            functions.appendToChannels(`controls${i}`, pickedChannels);
          });
      }

      [
        groupControlsTitle,
        groupSelector,
        groupControlsColorInput,
        groupControlsChannelInputs,
        groupControlsQuickActions,
        groupControlsDimmerInput,
        groupControlsFadeInput,
        groupControlsSubmit,
      ].forEach((a) => groupControlsContainer.appendChild(a));

      document
        .querySelector("#lightcontrolsgroup")
        .appendChild(groupControlsContainer);
    };

    static loadLightAll = () => {
      let allControlsContainer = document.createElement("div");
      allControlsContainer.classList.add("groupControlsContainer");
      allControlsContainer.id = "controlsGroupAll";

      let allControlsTitle = document.createElement("h");
      allControlsTitle.innerText = "Master Controls";
      allControlsTitle.classList.add("controlsTitle");

      let allControlsColorInput = elements.controlsColorInput(
        allControlsContainer.id
      );
      let allControlsChannelInputs = elements.controlsChannelInputs(
        allControlsContainer.id
      );
      let groupName = () => {
        return "_all";
      };
      let allControlsQuickActions = elements.controlsQuickActions(
        allControlsContainer.id,
        groupName,
        append
      );
      let allControlsDimmerInput = elements.controlsDimmerInput(
        allControlsContainer.id
      );
      let allControlsFadeInput = elements.controlsFadeInput(
        allControlsContainer.id
      );

      let allControlsSubmit = document.createElement("button");
      allControlsSubmit.innerText = "Update";
      allControlsSubmit.classList.add("controlsSubmit");

      allControlsSubmit.onclick = () => {
        append(true);
      };
      allControlsColorInput.onchange = () => {
        append(false, true, false);
      };
      allControlsChannelInputs.onchange = () => {
        append(false, false, true);
      };
      allControlsDimmerInput.onchange = () => {
        append();
      };
      allControlsFadeInput.onchange = () => {
        append();
      };

      function append(update, fromPicker, fromChannels, quickOverrideVal) {
        // quickOverrideVal = [[<rgb>],[<norgb>]]
        let pickedColorHex = allControlsColorInput.querySelector(
          ".controlsColorInput"
        ).value;
        let pickedDimm = allControlsDimmerInput.querySelector(
          ".controlsDimmerInput"
        ).value;
        let pickedFade = allControlsFadeInput.querySelector(
          ".controlsFadeInput"
        ).value;

        if (fromPicker)
          functions.appendHexToChannels(
            allControlsContainer.id,
            pickedColorHex
          );
        if (fromChannels)
          pickedColorHex = functions.appendValuesFromChannels(
            allControlsContainer.id
          );
        let pickedChannels = functions.getValuesFromChannels(
          allControlsContainer.id
        );

        let isOverridden =
          functions.getQuickState(groupName(), "fullOn") === 1 ||
          functions.getQuickState(groupName(), "fullOff") === 1;

        let isHeld = functions.getQuickState(groupName(), "isHeld") === 1;

        let rgbChans = lights
          .split(splitter)
          .filter((a) => parseInt(a.split(";")[2]) > 1)
          .map((a) => a.split(";")[1]);

        let noRGBChans = lights
          .split(splitter)
          .filter((a) => parseInt(a.split(";")[2]) === 1)
          .map((a) => a.split(";")[1]);

        if (isHeld)
          return quickStates[groupName()].heldActions.push([
            [
              rgbChans,
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade,
            ],
            [noRGBChans, pickedDimm, pickedFade],
          ]);

        if (quickOverrideVal) {
          functions.updateLightVal(rgbChans, quickOverrideVal[0], 0);
          functions.updateLightVal(noRGBChans, quickOverrideVal[1], 0);
        } else if ((update || liveUpdate) && !isOverridden) {
          if (rgbChans.length > 0)
            functions.updateLight(
              rgbChans.join(","),
              pickedDimm,
              ...Object.values(pickedChannels),
              pickedFade
            );

          if (noRGBChans.length > 0)
            functions.updateLightnoRGB(
              noRGBChans.join(","),
              pickedDimm,
              pickedFade
            );
        }

        lights
          .split(splitter)
          .map((a) => a.split(";"))
          .map((light) => {
            let i = light[1];
            if (!document.getElementById(`controls${i}`)) return;
            let isRGB = parseInt(light[2]) > 1;
            document.getElementById(`controls${i}-dimm`).value = pickedDimm;
            document.getElementById(`controls${i}-fade`).value = pickedFade;
            if (!isRGB) return;
            document.getElementById(
              `controls${i}-color`
            ).value = pickedColorHex;
            functions.appendToChannels(`controls${i}`, pickedChannels);
          });

        if (!document.getElementById(`controlsGroup`)) return;
        document.getElementById(`controlsGroup-color`).value = pickedColorHex;
        document.getElementById(`controlsGroup-dimm`).value = pickedDimm;
        document.getElementById(`controlsGroup-fade`).value = pickedFade;
        functions.appendToChannels(`controlsGroup`, pickedChannels);
      }

      [
        allControlsTitle,
        allControlsColorInput,
        allControlsChannelInputs,
        allControlsQuickActions,
        allControlsDimmerInput,
        allControlsFadeInput,
        allControlsSubmit,
      ].forEach((a) => allControlsContainer.appendChild(a));

      document
        .querySelector("#lightcontrolsgroup")
        .appendChild(allControlsContainer);
    };

    static loadLiveUpdateToggle = () => {
      let liveUpdateContainer = document.createElement("div");
      liveUpdateContainer.id = "liveUpdateContainer";

      let liveUpdateTitle = document.createElement("h");
      liveUpdateTitle.id = "liveUpdateTitle";
      liveUpdateTitle.innerText = "Live Update";

      let liveUpdateCheckbox = document.createElement("input");
      liveUpdateCheckbox.type = "checkbox";

      liveUpdateCheckbox.onchange = () => {
        liveUpdate = liveUpdateCheckbox.checked;
        scripts.appendLiveUpdate();
      };

      [liveUpdateTitle, liveUpdateCheckbox].forEach((a) =>
        liveUpdateContainer.appendChild(a)
      );

      document.querySelector("body").appendChild(liveUpdateContainer);
    };

    static loadGroupToggle = () => {
      let groupToggleContainer = document.createElement("div");
      groupToggleContainer.id = "groupToggleContainer";

      let groupToggleTitle = document.createElement("h");
      groupToggleTitle.id = "groupToggleTitle";
      groupToggleTitle.innerText = "Show groups";

      let groupToggleCheckbox = document.createElement("input");
      groupToggleCheckbox.type = "checkbox";
      groupToggleCheckbox.defaultChecked = true;

      groupToggleCheckbox.onchange = () => {
        groupToggle = groupToggleCheckbox.checked;
        scripts.appendGroupToggleUpdate();
      };

      [groupToggleTitle, groupToggleCheckbox].forEach((a) =>
        groupToggleContainer.appendChild(a)
      );

      document.querySelector("body").appendChild(groupToggleContainer);
    };

    static appendLiveUpdate = () => {
      let updateButtons = document.querySelectorAll(".controlsSubmit");
      updateButtons.forEach((a) => {
        if (liveUpdate) a.classList.add("hidden");
        else a.classList.remove("hidden");
      });

      let updateFades = document.querySelectorAll(".controlsFade");
      updateFades.forEach((a) => {
        if (liveUpdate) a.value = fadeLiveDefaultTime;
        else a.value = fadeDefaultTime;
      });
    };

    static appendGroupToggleUpdate = () => {
      let groupTitles = document.querySelectorAll(".controlsGroupTitle");
      groupTitles.forEach((a) => {
        if (!groupToggle) a.classList.add("hidden");
        else a.classList.remove("hidden");
      });
    };
  }

  class elements {
    static br = () => {
      return document.createElement("br");
    };
    static spacer = () => {
      return document.createElement("spacer");
    };

    static controlsColorInput = (containerID) => {
      let controlsColorPickerContainer = document.createElement("div");
      controlsColorPickerContainer.classList.add(
        "controlsColorPickerContainer"
      );

      let controlsColorPickerTitle = document.createElement("h");
      controlsColorPickerTitle.innerText = "Color Picker";

      let controlsColorPicker = document.createElement("input");
      if (containerID) controlsColorPicker.id = `${containerID}-color`;
      controlsColorPicker.classList.add("controlsColorInput");
      controlsColorPicker.type = "color";
      controlsColorPicker.defaultValue = "#000000";

      [controlsColorPickerTitle, controlsColorPicker].forEach((a) =>
        controlsColorPickerContainer.appendChild(a)
      );

      return controlsColorPickerContainer;
    };

    static controlsChannelInputs = (containerID) => {
      let channelsContainer = document.createElement("div");
      channelsContainer.classList.add("controlsChannelsContainer");

      let channelsContainerInner = document.createElement("div");

      let channelsTitle = document.createElement("h");
      channelsTitle.innerText = "Channels";

      let channelsInputContainer = document.createElement("div");
      if (containerID) channelsInputContainer.id = `${containerID}-channels`;
      channelsInputContainer.classList.add("controlsChannelsInputContainer");

      let channelTitlesContainer = document.createElement("div");
      if (containerID)
        channelTitlesContainer.id = `${containerID}-channel-titles`;
      channelTitlesContainer.classList.add("controlsChannelTitlesContainer");

      channels.forEach((channel) => {
        let channelInput = document.createElement("input");
        if (containerID)
          channelInput.id = `${channelsInputContainer.id}-${channel[1]}`;
        channelInput.classList.add(
          "controlsChannelInput",
          `controlsChannel-${channel[1]}`,
          "vertical"
        );
        channelInput.type = "range";
        channelInput.style.backgroundColor = channel[2];
        channelInput.min = rangeInputMin;
        channelInput.max = rangeInputMax;
        channelInput.defaultValue = channel[3];

        let channelTitle = document.createElement("h");
        channelTitle.classList.add("controlsChannelTitle");
        channelTitle.title = channel[0];
        channelTitle.innerText = channel[1];

        channelsInputContainer.appendChild(channelInput);
        channelTitlesContainer.appendChild(channelTitle);
      });

      [
        channelsTitle,
        channelsInputContainer,
        channelTitlesContainer,
      ].forEach((a) => channelsContainerInner.appendChild(a));
      channelsContainer.appendChild(channelsContainerInner);

      return channelsContainer;
    };

    static controlsDimmerInput = (containerID) => {
      let controlsDimmerContainer = document.createElement("div");
      controlsDimmerContainer.classList.add("controlsDimmerContainer");

      let controlsDimmerContainerInner = document.createElement("div");

      let controlsDimmerTitle = document.createElement("h");
      controlsDimmerTitle.innerText = "Dimmer";

      let controlsDimmerInput = document.createElement("input");
      if (containerID) controlsDimmerInput.id = `${containerID}-dimm`;

      controlsDimmerInput.classList.add("dimmer");
      controlsDimmerInput.classList.add("controlsDimmerInput", "horizontal");
      controlsDimmerInput.type = "range";
      controlsDimmerInput.min = rangeInputMin;
      controlsDimmerInput.max = 100;
      controlsDimmerInput.defaultValue = rangeInputDefault;

      [controlsDimmerTitle, controlsDimmerInput].forEach((a) =>
        controlsDimmerContainerInner.appendChild(a)
      );
      controlsDimmerContainer.appendChild(controlsDimmerContainerInner);

      return controlsDimmerContainer;
    };

    static controlsFadeInput = (containerID) => {
      let fadeContainer = document.createElement("div");
      fadeContainer.classList.add("controlsFadeContainer");

      let fadeContainerInner = document.createElement("div");

      let fadeTitle = document.createElement("h");
      fadeTitle.innerText = "Fade";

      let fadeInput = document.createElement("input");
      fadeInput.id = `${containerID}-fade`;
      fadeInput.classList.add("controlsFadeInput", "horizontal");
      fadeInput.type = "range";
      fadeInput.min = fadeRangeMin;
      fadeInput.max = fadeRangeMax;
      fadeInput.defaultValue = fadeRangeDefault;

      [fadeTitle, fadeInput].forEach((a) => fadeContainerInner.appendChild(a));
      fadeContainer.appendChild(fadeContainerInner);

      return fadeContainer;
    };

    static controlsQuickActions = (containerID, groupName, append) => {
      let actionGroup = () => {
        return groupName?.() ?? "_all";
      };
      let quickActionsContainer = document.createElement("div");
      quickActionsContainer.classList.add("controlsQuickActionsContainer");

      let quickActionsFullon = document.createElement("button");
      let quickActionsFulloff = document.createElement("button");
      let quickActionsHold = document.createElement("button");

      quickActionsFullon.innerText = "Full On";
      quickActionsFulloff.innerText = "Full Off";
      quickActionsHold.innerText = "Hold";

      function createQuickStates() {
        if (!quickStates[actionGroup()])
          quickStates[actionGroup()] = {
            fullOn: 0,
            fullOff: 0,
            isHeld: 0,
            heldActions: [],
          };
      }

      function setQuickState(a, v) {
        switch (a) {
          case "fullOn": {
            quickStates[actionGroup()].fullOn = v;
            quickStates[actionGroup()].fullOff = 2;
            break;
          }

          case "fullOff": {
            quickStates[actionGroup()].fullOff = v;
            quickStates[actionGroup()].fullOn = 2;
            break;
          }

          case "isHeld": {
            quickStates[actionGroup()].isHeld = v;
            break;
          }
        }
      }

      function quickButtonChanger(ev) {
        createQuickStates();
        let quickButtonNames = ["fullOn", "fullOff", "isHeld"];
        let quickButtons = [
          quickActionsFullon,
          quickActionsFulloff,
          quickActionsHold,
        ];
        let quickButtonIndex = quickButtons.indexOf(ev.target);
        let quickButtonOthers = [...quickButtons].filter(
          (a) => a !== ev.target
        );
        let quickButton = quickButtons[quickButtonIndex];
        let tag = quickButtonNames[quickButtonIndex];
        let state = functions.getQuickState(actionGroup(), tag);
        switch (state) {
          case 0:
          case 2: {
            functions.quickButtonActive(quickButton);

            setQuickState(tag, 1);

            switch (quickButtonNames[quickButtonIndex]) {
              case "fullOn":
              case "fullOff": {
                append(false, false, false, [
                  [0, 0, 0, [255, 0][quickButtonIndex], 0, 0],
                  [[255, 0][quickButtonIndex], 0, 0, 0, 0, 0],
                ]);
                break;
              }
            }
            break;
          }

          case 1: {
            functions.quickButtonInactive(quickButton);
            setQuickState(tag, 0);

            switch (quickButtonNames[quickButtonIndex]) {
              case "isHeld": {
                functions.appendHeld(groupName);
                break;
              }
            }
            break;
          }
        }

        switch (quickButtonNames[quickButtons.indexOf(quickButton)]) {
          case "fullOn":
          case "fullOff": {
            quickButtonOthers
              .filter((a) => a !== quickActionsHold)
              .forEach((a) => {
                functions.quickButtonInactive(a);
              });

            return;
          }

          case "isHeld": {
            quickButtonOthers.forEach((a) => {
              [functions.disableElem, functions.enableElem][state]?.(a);
              functions.quickButtonInactive(a);
              setQuickState(quickButtonNames[quickButtons.indexOf(a)], 2);
            });

            return;
          }
        }
      }

      [quickActionsFullon, quickActionsFulloff, quickActionsHold].map((a) => {
        a.classList.add("quickActionButton");
        quickActionsContainer.appendChild(a);
        a.onclick = quickButtonChanger;
      });

      return quickActionsContainer;
    };
  }

  window.onload = () => {
    scripts.loadLights();
    scripts.loadLightGroups();
    scripts.loadLightAll();
    scripts.loadLiveUpdateToggle();
    scripts.loadGroupToggle();
  };
</script>
<style>
  * {
    scrollbar-width: thin;
    font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande",
      "Lucida Sans", Arial, sans-serif;
    border-radius: 10px;
    /* word-break: normal; */
    /* line-break: anywhere; */
    text-align: center;
    user-select: none;
    padding: 3px;
  }

  .hidden {
    display: none;
  }

  @media screen and (-webkit-min-device-pixel-ratio: 0) {
    .controlsChannelInput {
      overflow: hidden;
      /* width: 80px; */
      appearance: none;
      -webkit-appearance: none;
      background-color: #fff;
      border: 1px solid;
    }

    .controlsChannelInput::-webkit-slider-runnable-track {
      height: 10px;
      appearance: none;
      -webkit-appearance: none;
      color: #fff;
      background-color: transparent;
      margin-top: -1px;
    }

    .controlsChannelInput::-webkit-slider-thumb {
      width: 10px;
      -webkit-appearance: none;
      height: 10px;
      border: 1px solid white;
      border-radius: 100%;
      background: transparent;
      /* box-shadow: -87px 0 2px 90px #fcca46; */
      box-shadow: 396px 0 2px 400px #000000;
    }
  }

  .horizontal {
    cursor: w-resize;
  }

  .vertical {
    cursor: n-resize;
  }

  .controlsChannelInput {
    border: 1px solid white;
    background-color: #000000;
  }

  .controlsChannelInput::-moz-range-progress {
    background-color: #fcca46;
  }

  .controlsChannelInput::-moz-range-track {
    background-color: #000000;
  }

  /* .dimmer {
        background-color: white;
    } */

  body {
    background-color: #233d4d;
    transition: ease-in 2s;
    color: #f1faee;
    padding: 3px;
  }

  #lightcontrols,
  #lightcontrolsgroup {
    display: flex;
    place-items: center;
    flex-wrap: wrap;
    justify-content: center;
    align-items: stretch;
  }

  .controlsContainer {
    display: flex;
    flex: 1 0 24%;
  }

  .controlsContainer,
  .groupControlsContainer {
    max-width: 23%;
    padding: 6px;
    margin: 2px;
    width: 25%;
    gap: 3px;
    border: 1px solid;
    background-color: #1d2d44;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-evenly;
  }

  /* #lightcontrolsgroup {
        display: flex;
        justify-content: center;
    } */

  .groupControlsContainer {
    max-width: none;
    width: 40%;
  }

  spacer {
    display: flex;
    height: 10px;
  }

  .controlsTitle {
    font-size: large;
    height: 50%;
    /* word-break: break-all; */
  }

  .controlsDimmerInput,
  .controlsFadeInput {
    width: 80%;
  }

  .controlsColorInput,
  .controlsSubmit {
    border: none;
    outline: none;
  }

  .controlsSelector {
    border: 1px solid transparent;
  }

  .controlsColorInput {
    background-color: transparent;
    box-sizing: content-box;
    padding: 0;
    height: 30px;
  }

  .controlsSubmit {
    padding: 4px;
  }

  .controlsGroupTitle {
    font-size: small;
    overflow-y: auto;
    height: 50%;
    /* word-break: break-all; */
  }

  .controlsColorPickerContainer,
  .controlsChannelsContainer,
  .controlsDimmerContainer,
  .controlsFadeContainer,
  .controlsQuickActionsContainer {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    border: 1px solid;

    flex-direction: column;
    width: 100%;
  }

  .controlsDimmerContainer > div,
  .controlsFadeContainer > div {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 90%;
  }

  .controlsQuickActionsContainer {
    flex-direction: row;
  }

  @media screen and (max-width: 700px) {
    .controlsChannelsContainer {
      display: none;
    }
  }

  .controlsChannelsContainer {
    flex-direction: column;
    flex-wrap: nowrap;
    /* height: 218px; */
  }

  /* .controlsColorPickerContainer { */
  /* min-width: 205px; */
  /* } */

  .controlsChannelsInputContainer {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    flex-direction: column;
    transform: rotate(-90deg);
    row-gap: 1px;
    /* row-gap: 7.5px; */
    /* min-width: 160px; */
    /* width: min-content; */
    justify-content: center;
    aspect-ratio: 1/1.2;
  }

  .controlsChannelTitle {
    /* display: flex; */
    cursor: help;
  }

  .controlsChannelTitlesContainer {
    display: flex;
    /* gap: 10px; */
    justify-content: space-evenly;
  }

  .controlsColorPickerContainer {
    flex-direction: column;
    justify-content: center;
  }

  #liveUpdateContainer {
    background-color: #38a3a5;
    z-index: 10;
    position: absolute;
    right: 10px;
    top: 10px;
  }

  #groupToggleContainer {
    background-color: #38a3a5;
    z-index: 10;
    position: absolute;
    left: 10px;
    top: 10px;
  }

  .quickActionButton {
    display: flex;
    border-radius: 6px;
    border: 1px solid #f1faee;
    margin: 2px;
    background-color: #220901;
    color: #f1faee;
  }

  .quickActionButton:disabled {
    color: grey;
  }

  @keyframes blink {
    0%,
    49% {
      background-color: red;
      color: black;
    }

    50%,
    99% {
      background-color: #220901;
      /* color: #f1faee; */
      color: red;
    }
  }

  .quickActionButton-active {
    background-color: #a1c181;
    animation: blink 1s infinite;
  }

  .controlsContainerTop,
  .controlsContainerBottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    /* justify-content: space-evenly; */
    margin: 0;
    padding: 0;
    width: 100%;
    gap: 2px;
  }

  .controlsContainerTop {
    height: 45%;
  }

  .controlsContainerTop {
    height: 55%;
  }
</style>
